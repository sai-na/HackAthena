import React, { useState, useCallback, useEffect, useDeferredValue, useContext, useMemo, memo, createContext, useRef, Suspense, lazy } from 'react';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { useQuery, useQueryClient, useMutation } from '@tanstack/react-query';
import { resolveIpfsUri, ThirdwebThemeContext, useSupportedChains, useSwitchChain, useChainId, useThirdwebWallet, useCreateWalletInstance, useDisconnect, useAddress, useBalance, useWallet, useSDK, useConnectionStatus, useThirdwebAuthContext, useUser, useLogin, useLogout, resolveMimeType, useSDKChainId, useNetworkMismatch, useContract, useConnect, useActiveChain, useWallets, ThirdwebProviderCore } from '@thirdweb-dev/react-core';
import { keyframes, useTheme, ThemeProvider } from '@emotion/react';
import styled from '@emotion/styled';
import * as RXPopover from '@radix-ui/react-popover';
import copy from 'copy-to-clipboard';
import { CheckIcon, CopyIcon as CopyIcon$1, Cross2Icon, MagnifyingGlassIcon, ChevronLeftIcon, EyeClosedIcon, EyeOpenIcon, ChevronRightIcon, ShuffleIcon, ChevronDownIcon, ExclamationTriangleIcon, CheckCircledIcon, CrossCircledIcon, UploadIcon, InfoCircledIcon } from '@radix-ui/react-icons';
import * as Tabs from '@radix-ui/react-tabs';
import Fuse from 'fuse.js';
import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
import { defaultChains, Localhost } from '@thirdweb-dev/chains';
import { utils } from 'ethers';
import invariant from 'tiny-invariant';
import { mauveDark, tomato, green, blue, mauve } from '@radix-ui/colors';
import * as Dialog from '@radix-ui/react-dialog';
import { Title } from '@radix-ui/react-dialog';
import { detect } from 'detect-browser';
import { CoinbaseWallet, MetaMaskWallet, WalletConnectV1, assertWindowEthereum, SafeSupportedChainsSet } from '@thirdweb-dev/wallets';
import ReactQrCode from 'react-qr-code';
import * as RadixTooltip from '@radix-ui/react-tooltip';

const coinbaseWallet = () => {
  return {
    id: CoinbaseWallet.id,
    meta: CoinbaseWallet.meta,
    create: options => new CoinbaseWallet({
      ...options,
      headlessMode: true
    })
  };
};

var coinbaseWallet$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  coinbaseWallet: coinbaseWallet
});

const metamaskWallet = () => {
  return {
    id: MetaMaskWallet.id,
    meta: MetaMaskWallet.meta,
    create: options => new MetaMaskWallet({
      ...options,
      qrcode: false
    })
  };
};

var metamaskWallet$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  metamaskWallet: metamaskWallet
});

const walletConnectV1 = () => {
  return {
    id: WalletConnectV1.id,
    meta: WalletConnectV1.meta,
    create: options => new WalletConnectV1({
      ...options,
      qrcode: true
    })
  };
};

var walletConnectV1$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  walletConnectV1: walletConnectV1
});

const darkTheme = {
  overlay: {
    subdued: "rgba(0, 0, 0, 0.74)"
  },
  bg: {
    base: mauveDark.mauve1,
    baseHover: mauveDark.mauve2,
    elevated: mauveDark.mauve3,
    elevatedHover: mauveDark.mauve4,
    highlighted: mauveDark.mauve5,
    inverted: mauveDark.mauve12,
    invertedFocused: mauveDark.mauve7,
    danger: tomato.tomato12
  },
  border: {
    base: mauveDark.mauve3,
    elevated: mauveDark.mauve4
  },
  badge: {
    secondary: mauveDark.mauve6
  },
  text: {
    neutral: mauveDark.mauve12,
    inverted: mauveDark.mauve1,
    secondary: mauveDark.mauve9,
    danger: tomato.tomato9
  },
  icon: {
    secondary: mauveDark.mauve11,
    primary: mauveDark.mauve12,
    inverted: mauveDark.mauve1,
    danger: tomato.tomato9,
    success: green.green7,
    link: blue.blue9
  },
  link: {
    primary: blue.blue9,
    primaryHover: mauveDark.mauve12
  },
  input: {
    bg: mauveDark.mauve3,
    bgHover: mauveDark.mauve5,
    outline: mauveDark.mauve5,
    focusRing: blue.blue9,
    errorRing: tomato.tomato9
  },
  tooltip: {
    bg: "black",
    text: "white"
  }
};
const lightTheme = {
  overlay: {
    subdued: "rgba(0, 0, 0, 0.4)"
  },
  bg: {
    base: mauve.mauve1,
    baseHover: mauve.mauve2,
    elevated: mauve.mauve3,
    elevatedHover: mauve.mauve4,
    highlighted: mauve.mauve5,
    inverted: mauve.mauve12,
    invertedFocused: mauve.mauve7,
    danger: tomato.tomato4
  },
  border: {
    base: mauve.mauve6,
    elevated: mauve.mauve7
  },
  badge: {
    secondary: mauve.mauve1
  },
  text: {
    neutral: mauve.mauve12,
    inverted: mauve.mauve1,
    secondary: mauve.mauve10,
    danger: tomato.tomato9
  },
  icon: {
    secondary: mauve.mauve10,
    primary: mauve.mauve12,
    inverted: mauve.mauve1,
    danger: tomato.tomato9,
    success: green.green9,
    link: blue.blue11
  },
  link: {
    primary: blue.blue11,
    primaryHover: mauve.mauve12
  },
  input: {
    bg: mauve.mauve3,
    bgHover: mauveDark.mauve5,
    outline: mauve.mauve7,
    focusRing: blue.blue11,
    errorRing: tomato.tomato10
  },
  tooltip: {
    bg: "black",
    text: "white"
  }
};
const fontSize = {
  xs: "12px",
  sm: "14px",
  md: "16px",
  lg: "20px",
  xl: "24px"
};
const spacing = {
  xxs: "6px",
  xs: "8px",
  sm: "12px",
  md: "16px",
  lg: "24px",
  xl: "32px",
  xxl: "48px"
};
const radius = {
  sm: "6px",
  md: "8px",
  lg: "12px",
  xl: "20px",
  xxl: "32px"
};
const iconSize = {
  xs: "12",
  sm: "16",
  md: "24",
  lg: "32",
  xl: "48"
};

// desktop first style media query
const media = {
  mobile: `@media (max-width: 640px)`
};
const shadow = {
  sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
  md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
  lg: "0 10px 15px -3px rgb(0 0 0 / 0.07), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
  xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)"
};

const defaultChainIcon = resolveIpfsUri("ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png");
const ChainIcon = props => {
  const url = props.chain?.icon?.url;
  const src = url ? resolveIpfsUri(url) : defaultChainIcon;
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      display: "flex",
      flexShrink: 0,
      alignItems: "center"
    },
    children: [/*#__PURE__*/jsx("img", {
      src: src || defaultChainIcon,
      onError: e => {
        if (defaultChainIcon && e.currentTarget.src !== defaultChainIcon) {
          e.currentTarget.src = defaultChainIcon;
        }
      },
      alt: "",
      width: props.size,
      height: props.size,
      className: props.className,
      loading: props.loading,
      style: {
        objectFit: "contain",
        width: props.size + "px",
        height: props.size + "px"
      }
    }), props.active && /*#__PURE__*/jsx(ActiveDot, {})]
  });
};
const ActiveDot = styled.div`
  width: 28%;
  height: 28%;
  border-radius: 50%;
  position: absolute;
  top: 60%;
  right: 0px;
  background-color: #00d395;
  box-shadow: 0 0 0 2px ${p => p.theme.bg.elevated};
`;

// extracted from chakra-ui
/**
 * React hook to copy content to clipboard
 *
 */
function useClipboard(text) {
  let optionsOrTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const [hasCopied, setHasCopied] = useState(false);
  const {
    timeout = 1500,
    ...copyOptions
  } = typeof optionsOrTimeout === "number" ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout;
  const onCopy = useCallback(() => {
    const didCopy = copy(text, copyOptions);
    setHasCopied(didCopy);
  }, [text, copyOptions]);
  useEffect(() => {
    let timeoutId = null;
    if (hasCopied) {
      timeoutId = window.setTimeout(() => {
        setHasCopied(false);
      }, timeout);
    }
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy,
    hasCopied
  };
}

const ToolTip = props => {
  return /*#__PURE__*/jsx(RadixTooltip.Provider, {
    delayDuration: 200,
    children: /*#__PURE__*/jsxs(RadixTooltip.Root, {
      children: [/*#__PURE__*/jsx(RadixTooltip.Trigger, {
        asChild: true,
        children: props.children
      }), /*#__PURE__*/jsx(RadixTooltip.Portal, {
        children: /*#__PURE__*/jsxs(TooltipContent, {
          sideOffset: props.sideOffset || 6,
          align: props.align,
          side: props.side,
          children: [props.tip, /*#__PURE__*/jsx(TooltipArrow, {})]
        })
      })]
    })
  });
};
const slideUpAndFade$1 = keyframes`
from {
  opacity: 0;
  transform: translateY(2px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
`;
const TooltipContent = styled(RadixTooltip.Content)`
  background: ${p => p.theme.tooltip.bg};
  color: ${p => p.theme.tooltip.text};
  border-radius: ${radius.sm};
  line-height: 1;
  padding: ${spacing.sm} ${spacing.md};
  font-size: ${fontSize.sm};
  box-shadow: ${shadow.sm};
  user-select: none;
  will-change: transform, opacity;
  animation: ${slideUpAndFade$1} 200ms cubic-bezier(0.16, 1, 0.3, 1);
  z-index: 999999999999999;
  max-width: 300px;
  line-height: 1.5;
`;
const TooltipArrow = styled(RadixTooltip.Arrow)`
  fill: ${p => p.theme.tooltip.bg};
`;

const CopyIcon = props => {
  const {
    hasCopied,
    onCopy
  } = useClipboard(props.text);
  return /*#__PURE__*/jsx("div", {
    onClick: onCopy,
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    children: /*#__PURE__*/jsx(ToolTip, {
      tip: props.tip,
      side: props.side,
      align: props.align,
      children: hasCopied ? /*#__PURE__*/jsx(CheckIconStyled, {}) : /*#__PURE__*/jsx(CopyIcon$1, {})
    })
  });
};
const CheckIconStyled = styled(CheckIcon)`
  color: ${p => p.theme.icon.success};
`;

const Img = props => {
  return /*#__PURE__*/jsx("img", {
    width: props.width,
    height: props.height,
    src: resolveIpfsUri(props.src),
    alt: props.alt || "",
    loading: props.loading,
    decoding: "async",
    style: {
      height: props.height + "px",
      width: props.width + "px"
    },
    className: props.className
  });
};

const scrollbar = _ref => {
  let {
    track,
    thumb,
    hover
  } = _ref;
  return `
&::-webkit-scrollbar {
  width: 6px;
}

&::-webkit-scrollbar-track {
  box-shadow: inset 0 0 5px ${track};
  border-radius: ${radius.md};
}

&::-webkit-scrollbar-thumb {
  background: ${thumb};
  border-radius: ${radius.md};
}

&::-webkit-scrollbar-thumb:hover {
  background: ${hover};
}`;
};

const overlayEnter = keyframes`
 from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
const Overlay = styled.div`
  background-color: ${p => p.theme.overlay.subdued};
  z-index: 9999;
  position: fixed;
  inset: 0;
  animation: ${overlayEnter} 400ms cubic-bezier(0.16, 1, 0.3, 1);
`;

// for rendering a conventional button
const Button = styled.button`
  all: unset;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: ${radius.md};
  padding: ${spacing.sm} ${spacing.sm};
  font-size: ${fontSize.md};
  font-weight: 500;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  flex-shrink: 0;

  &:focus {
    box-shadow: 0 0 0 3px
      ${p => {
  switch (p.variant) {
    case "inverted":
      return p.theme.bg.invertedFocused;
    case "secondary":
      return p.theme.bg.highlighted;
    case "danger":
      return p.theme.text.danger;
  }
}};
  }

  box-shadow: ${p => {
  switch (p.variant) {
    case "danger":
      return `0 0 0 2px ${p.theme.text.danger}`;
    default:
      return "none";
  }
}};

  background: ${p => {
  switch (p.variant) {
    case "inverted":
      return p.theme.bg.inverted;
    case "secondary":
      return p.theme.bg.elevated;
    case "link":
      return "transparent";
    case "danger":
      return "none";
  }
}};
  color: ${p => {
  switch (p.variant) {
    case "inverted":
      return p.theme.text.inverted;
    case "secondary":
      return p.theme.text.neutral;
    case "link":
      return p.theme.link.primary;
    case "danger":
      return p.theme.text.danger;
  }
}};
  cursor: pointer;

  /* pressed effect */
  &:active {
    transform: translateY(1px);
  }

  &[disabled] {
    cursor: not-allowed;
  }
`;

// for rendering a button with an icon
const IconButton = styled.button`
  all: unset;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: ${radius.sm};
  -webkit-tap-highlight-color: transparent;
  color: ${p => {
  switch (p.variant) {
    case "neutral":
      return p.theme.text.neutral;
    case "secondary":
      return p.theme.text.secondary;
  }
}};
  padding: 2px;
  transition: background 0.2s ease, color 0.2s ease;
  &:hover {
    background: ${p => p.theme.bg.elevated};
    color: ${p => p.theme.text.neutral};
  }
`;

// for rendering a button next to input
const InputButton = styled.button`
  all: unset;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: ${radius.sm};
  padding: ${spacing.sm};
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  color: ${p => p.theme.text.secondary};
  &:hover {
    color: ${p => p.theme.text.neutral};
  }
`;

const Modal = props => {
  return /*#__PURE__*/jsxs(Dialog.Root, {
    open: props.open,
    onOpenChange: props.setOpen,
    children: [props.trigger && /*#__PURE__*/jsx(Dialog.Trigger, {
      asChild: true,
      children: props.trigger
    }), /*#__PURE__*/jsxs(Dialog.Portal, {
      children: [/*#__PURE__*/jsx(Dialog.Overlay, {
        asChild: true,
        children: /*#__PURE__*/jsx(Overlay, {})
      }), /*#__PURE__*/jsx(Dialog.Content, {
        asChild: true,
        children: /*#__PURE__*/jsxs(DialogContent, {
          style: props.style,
          children: [props.title && /*#__PURE__*/jsxs(DialogTitle, {
            children: [" ", props.title]
          }), props.children, !props.hideCloseIcon && /*#__PURE__*/jsx(CrossContainer, {
            children: /*#__PURE__*/jsx(Dialog.Close, {
              asChild: true,
              children: /*#__PURE__*/jsx(IconButton, {
                variant: "secondary",
                type: "button",
                "aria-label": "Close",
                children: /*#__PURE__*/jsx(Cross2Icon, {
                  style: {
                    width: iconSize.md,
                    height: iconSize.md,
                    color: "inherit"
                  }
                })
              })
            })
          })]
        })
      })]
    })]
  });
};
const CrossContainer = styled.div`
  position: absolute;
  top: ${spacing.lg};
  right: ${spacing.lg};

  ${media.mobile} {
    right: ${spacing.md};
  }
`;
const modalAnimationDesktop = keyframes`
  from {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
`;
const modalAnimationMobile = keyframes`
  from {
    opacity: 0;
    transform: translate(0, 50%);
  }
  to {
    opacity: 1;
    transform: translate(0, 0);
  }
`;
const DialogContent = styled.div`
  z-index: 10000;
  background-color: ${p => p.theme.bg.base};
  border-radius: ${radius.xl};
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: calc(100vw - 40px);
  box-sizing: border-box;
  overflow-y: auto;
  padding: ${spacing.lg};
  padding-bottom: ${spacing.xl};
  animation: ${modalAnimationDesktop} 200ms ease;
  box-shadow: ${shadow.lg};
  line-height: 1;

  &:focus {
    outline: none;
  }

  ${p => scrollbar({
  track: "transparent",
  thumb: p.theme.bg.elevated,
  hover: p.theme.bg.highlighted
})}

  /* open from bottom on mobile */
  ${media.mobile} {
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 100vw;
    transform: none;
    width: 100vw;
    animation: ${modalAnimationMobile} 0.35s cubic-bezier(0.15, 1.15, 0.6, 1);
    border-radius: ${radius.xxl};
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
    max-width: none !important;
  }

  & *::selection {
    background-color: ${p => p.theme.bg.inverted};
    color: ${p => p.theme.text.inverted};
  }
`;
const DialogTitle = styled(Dialog.Title)`
  margin: 0;
  font-weight: 500;
  color: ${p => p.theme.text.neutral};
  font-size: ${fontSize.lg};
`;

const Skeleton = props => {
  return /*#__PURE__*/jsx(SkeletonDiv, {
    style: {
      height: props.height,
      width: props.width || "auto"
    }
  });
};
const skeletonAnimation = keyframes`
0% {
    background-color: var(--skeleton-c-1);
  }
  100% {
    background-color: var(--skeleton-c-2);
  }
`;
const SkeletonDiv = styled.div`
  background-size: 200% 200%;
  --skeleton-c-1: ${p => p.theme.bg.elevated};
  --skeleton-c-2: ${p => p.theme.bg.highlighted};
  animation: ${skeletonAnimation} 500ms ease-in-out infinite alternate;
  border-radius: ${radius.sm};
`;

const Spacer = _ref => {
  let {
    y
  } = _ref;
  return /*#__PURE__*/jsx("div", {
    style: {
      height: spacing[y]
    }
  });
};

function shortenString(str, extraShort) {
  return `${str.substring(0, extraShort ? 4 : 6)}...${str.substring(str.length - (extraShort ? 3 : 4))}`;
}
function shortenAddress(address, extraShort) {
  try {
    const formattedAddress = utils.getAddress(address);
    return shortenString(formattedAddress, extraShort);
  } catch {
    return address;
  }
}

function detectEnv(userAgent) {
  return detect(userAgent);
}

/**
 * @internal
 */
function isAndroid() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("android") : false;
}

/**
 * @internal
 */
function isIOS() {
  const os = detectOS();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}

/**
 * @internal
 */
function detectOS() {
  const env = detectEnv();
  return env?.os ? env.os : undefined;
}

/**
 * @internal
 */
function isMobile() {
  const os = detectOS();
  return os ? isAndroid() || isIOS() : false;
}

const Spinner = props => {
  const theme = useTheme();
  return /*#__PURE__*/jsx(Svg, {
    style: {
      width: iconSize[props.size],
      height: iconSize[props.size]
    },
    viewBox: "0 0 50 50",
    children: /*#__PURE__*/jsx(Circle$1, {
      cx: "25",
      cy: "25",
      r: "20",
      fill: "none",
      stroke: theme.icon[props.color || "primary"],
      strokeWidth: "4"
    })
  });
};

// animations
const dashAnimation = keyframes`
 0% {
    stroke-dasharray: 1, 150;
    stroke-dashoffset: 0;
  }
  50% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -35;
  }
  100% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -124;
  }
`;
const rotateAnimation = keyframes`
100% {
    transform: rotate(360deg);
  }
`;

// styles
const Svg = styled.svg`
  animation: ${rotateAnimation} 2s linear infinite;
  width: 1em;
  height: 1em;
`;
const Circle$1 = styled.circle`
  stroke-linecap: round;
  animation: ${dashAnimation} 1.5s ease-in-out infinite;
`;

const Label = styled.label`
  font-size: ${fontSize.sm};
  color: ${p => p.theme.text.neutral};
  display: block;
`;
const Input = styled.input`
  font-size: ${fontSize.md};
  display: block;
  padding: ${spacing.sm};
  box-sizing: border-box;
  width: 100%;
  outline: none;
  border: none;
  border-radius: 6px;
  color: ${p => p.theme.text.neutral};
  -webkit-appearance: none;
  appearance: none;
  background: ${p => {
  switch (p.variant) {
    case "secondary":
      return p.theme.bg.elevated;
    default:
      return "transparent";
  }
}};

  &::placeholder {
    color: ${p => p.theme.text.secondary};
  }

  box-shadow: 0 0 0 1.5px
    ${p => {
  switch (p.variant) {
    case "outline":
      return p.theme.input.outline;
    case "transparent":
      return "transparent";
    case "secondary":
      return p.theme.bg.elevated;
  }
}};

  /* when browser auto-fills the input  */
  &:-webkit-autofill {
    -webkit-text-fill-color: ${p => p.theme.text.neutral};
    -webkit-box-shadow: 0 0 0px 1000px ${p => p.theme.bg.elevated} inset;
    box-shadow: 0 0 0px 1000px ${p => p.theme.bg.elevated} inset;
    /* transition: background-color 5000s ease-in-out 0s; */
  }

  &:focus {
    box-shadow: 0 0 0 2px ${p => p.theme.input.focusRing};
  }

  /* show overflow ellipsis for long text - but not if it's a type="password"  */
  &:not([type="password"]) {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  &[data-error="true"] {
    box-shadow: 0 0 0 2px ${p => p.theme.input.errorRing};
  }

  &[disabled] {
    cursor: not-allowed;
  }
`;

// for rendering a input and a button side by side
const InputContainer = styled.div`
  display: flex;
  border-radius: ${radius.sm};
  box-shadow: 0 0 0px 1.5px ${p => p.theme.input.outline};

  /* show focus ring on container instead of input  */
  &:focus-within {
    box-shadow: 0 0 0px 2px ${p => p.theme.input.focusRing};
  }

  input:focus {
    box-shadow: none;
  }

  /* show error ring on container instead of input  */
  &[data-error="true"] {
    box-shadow: 0 0 0px 2px ${p => p.theme.input.errorRing};
  }
`;
const ErrorMessage$2 = styled.p`
  all: unset;
  font-size: ${fontSize.xs};
  display: block;
  color: ${p => p.theme.input.errorRing};
`;
const FormFooter = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${spacing.md};
`;

const fuseConfig = {
  threshold: 0.4,
  keys: [{
    name: "name",
    weight: 1
  }, {
    name: "chainId",
    weight: 1
  }]
};
const NetworkSelector = props => {
  const [searchTerm, setSearchTerm] = useState("");
  const deferredSearchTerm = useDeferredValue(searchTerm);
  const themeFromProvider = useContext(ThirdwebThemeContext);
  const theme = props.theme || themeFromProvider || "dark";
  const supportedChains = useSupportedChains();
  const chains = props.chains || supportedChains;
  const _recentChains = props.recentChains;

  // remove recent chains from popular chains
  const cleanedPopularChains = !_recentChains ? props.popularChains : props.popularChains?.filter(chain => {
    return !_recentChains.some(recentChain => recentChain.chainId === chain.chainId);
  });

  // fuse instances
  const fuseAllChains = useMemo(() => {
    return new Fuse(chains, fuseConfig);
  }, [chains]);
  const fusePopularChains = useMemo(() => {
    return new Fuse(cleanedPopularChains || [], fuseConfig);
  }, [cleanedPopularChains]);
  const fuseRecentChains = useMemo(() => {
    return new Fuse(props.recentChains || [], fuseConfig);
  }, [props.recentChains]);

  // chains filtered by search term
  const allChains = useMemo(() => {
    if (deferredSearchTerm === "") {
      return chains;
    }
    return fuseAllChains.search(deferredSearchTerm).map(r => r.item);
  }, [fuseAllChains, deferredSearchTerm, chains]);
  const popularChains = useMemo(() => {
    if (deferredSearchTerm === "") {
      return cleanedPopularChains || [];
    }
    return fusePopularChains.search(deferredSearchTerm).map(r => r.item);
  }, [fusePopularChains, deferredSearchTerm, cleanedPopularChains]);
  const recentChains = useMemo(() => {
    if (deferredSearchTerm === "") {
      return props.recentChains || [];
    }
    return fuseRecentChains.search(deferredSearchTerm).map(r => r.item);
  }, [fuseRecentChains, deferredSearchTerm, props.recentChains]);
  const {
    onClose,
    onSwitch,
    onCustomClick
  } = props;
  const handleSwitch = useCallback(chain => {
    if (onSwitch) {
      onSwitch(chain);
    }
    if (onClose) {
      onClose();
    }
  }, [onSwitch, onClose]);
  return /*#__PURE__*/jsx(ThemeProvider, {
    theme: theme === "dark" ? darkTheme : lightTheme,
    children: /*#__PURE__*/jsxs(Modal, {
      open: true,
      setOpen: value => {
        if (!value && onClose) {
          onClose();
        }
      },
      title: "Select Network",
      style: {
        maxWidth: "480px",
        paddingBottom: props.onCustomClick ? spacing.md : "0px"
      },
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(Tabs.Root, {
        className: "TabsRoot",
        defaultValue: "all",
        children: [/*#__PURE__*/jsxs(Tabs.List, {
          className: "TabsList",
          "aria-label": "Manage your account",
          style: {
            display: "flex",
            gap: spacing.xxs
          },
          children: [/*#__PURE__*/jsx(TabButton, {
            className: "TabsTrigger",
            value: "all",
            children: "All"
          }), /*#__PURE__*/jsx(TabButton, {
            className: "TabsTrigger",
            value: "mainnet",
            children: "Mainnets"
          }), /*#__PURE__*/jsx(TabButton, {
            className: "TabsTrigger",
            value: "testnet",
            children: "Testnets"
          })]
        }), /*#__PURE__*/jsx(Spacer, {
          y: "lg"
        }), /*#__PURE__*/jsxs("div", {
          style: {
            display: "flex",
            alignItems: "center",
            position: "relative"
          },
          children: [/*#__PURE__*/jsx(StyledMagnifyingGlassIcon, {
            width: iconSize.md,
            height: iconSize.md
          }), /*#__PURE__*/jsx(SearchInput, {
            style: {
              boxShadow: "none"
            },
            tabIndex: isMobile() ? -1 : 0,
            variant: "secondary",
            placeholder: "Search Network or Chain ID",
            value: searchTerm,
            onChange: e => {
              setSearchTerm(e.target.value);
            }
          }), deferredSearchTerm !== searchTerm && /*#__PURE__*/jsx("div", {
            style: {
              position: "absolute",
              right: spacing.md
            },
            children: /*#__PURE__*/jsx(Spinner, {
              size: "md",
              color: "link"
            })
          })]
        }), /*#__PURE__*/jsx(Spacer, {
          y: "lg"
        }), /*#__PURE__*/jsx(Tabs.Content, {
          className: "TabsContent",
          value: "all",
          children: /*#__PURE__*/jsx(NetworkTab, {
            allChains: allChains,
            type: "all",
            popularChains: popularChains,
            recentChains: recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), /*#__PURE__*/jsx(Tabs.Content, {
          className: "TabsContent",
          value: "mainnet",
          children: /*#__PURE__*/jsx(NetworkTab, {
            allChains: allChains,
            type: "mainnet",
            popularChains: popularChains,
            recentChains: recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), /*#__PURE__*/jsx(Tabs.Content, {
          className: "TabsContent",
          value: "testnet",
          children: /*#__PURE__*/jsx(NetworkTab, {
            allChains: allChains,
            type: "testnet",
            popularChains: popularChains,
            recentChains: recentChains,
            onSwitch: handleSwitch,
            renderChain: props.renderChain,
            close: props.onClose
          })
        }), onCustomClick && /*#__PURE__*/jsxs(Fragment, {
          children: [/*#__PURE__*/jsx(Spacer, {
            y: "sm"
          }), /*#__PURE__*/jsx(Button, {
            variant: "link",
            onClick: () => {
              onCustomClick();
              if (onClose) {
                onClose();
              }
            },
            style: {
              display: "flex",
              width: "100%",
              fontSize: fontSize.sm,
              boxShadow: "none"
            },
            children: "Add Custom Network"
          })]
        })]
      })]
    })
  });
};
const filterChainByType = (chains, type) => {
  if (type === "all") {
    return chains;
  }
  if (type === "testnet") {
    return chains.filter(c => c.testnet);
  }
  return chains.filter(c => !c.testnet);
};
const NetworkTab = props => {
  const allChains = useMemo(() => filterChainByType(props.allChains, props.type), [props.type, props.allChains]);
  const recentChains = useMemo(() => filterChainByType(props.recentChains || [], props.type), [props.type, props.recentChains]);
  const popularChains = useMemo(() => filterChainByType(props.popularChains || [], props.type), [props.type, props.popularChains]);
  return /*#__PURE__*/jsxs(ScrollContainer, {
    style: {
      height: "330px"
    },
    children: [recentChains.length > 0 && /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(SectionLabel, {
        children: "Recently Used"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(NetworkList, {
        chains: recentChains,
        onSwitch: props.onSwitch,
        renderChain: props.renderChain,
        close: props.close
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      })]
    }), popularChains.length > 0 && /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(SectionLabel, {
        children: "Popular"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(NetworkList, {
        chains: popularChains,
        onSwitch: props.onSwitch,
        renderChain: props.renderChain,
        close: props.close
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      })]
    }), (popularChains.length > 0 || recentChains.length > 0) && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(SectionLabel, {
        children: "All Networks"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      })]
    }), /*#__PURE__*/jsx(NetworkList, {
      chains: allChains,
      onSwitch: props.onSwitch,
      renderChain: props.renderChain,
      close: props.close
    })]
  });
};
const NetworkList = /*#__PURE__*/memo(function NetworkList(props) {
  const switchChain = useSwitchChain();
  const activeChainId = useChainId();
  const [switchingChainId, setSwitchingChainId] = useState(-1);
  const [errorSwitchingChainId, setErrorSwitchingChainId] = useState(-1);
  const handleSwitch = async chain => {
    setErrorSwitchingChainId(-1);
    setSwitchingChainId(chain.chainId);
    try {
      await switchChain(chain.chainId);
      props.onSwitch(chain);
    } catch (e) {
      setErrorSwitchingChainId(chain.chainId);
      console.error(e);
    } finally {
      setSwitchingChainId(-1);
    }
  };
  const RenderChain = props.renderChain;
  return /*#__PURE__*/jsx(NetworkListUl, {
    children: props.chains.map(chain => {
      const confirming = switchingChainId === chain.chainId;
      const switchingFailed = errorSwitchingChainId === chain.chainId;
      const chainName = /*#__PURE__*/jsxs("span", {
        children: [chain.name, " "]
      });
      if (RenderChain) {
        return /*#__PURE__*/jsx("li", {
          children: /*#__PURE__*/jsx(RenderChain, {
            switchChain: () => {
              handleSwitch(chain);
            },
            chain: chain,
            switching: switchingChainId === chain.chainId,
            switchFailed: errorSwitchingChainId === chain.chainId,
            close: props.close
          })
        }, chain.chainId);
      }
      return /*#__PURE__*/jsx("li", {
        children: /*#__PURE__*/jsxs(NetworkButton, {
          "data-active": activeChainId === chain.chainId,
          onClick: () => {
            handleSwitch(chain);
          },
          children: [/*#__PURE__*/jsx(ChainIcon, {
            chain: chain,
            size: iconSize.lg,
            active: activeChainId === chain.chainId,
            loading: "lazy"
          }), confirming || switchingFailed ? /*#__PURE__*/jsxs("div", {
            style: {
              display: "flex",
              flexDirection: "column",
              gap: spacing.xs
            },
            children: [chainName, /*#__PURE__*/jsxs("div", {
              style: {
                display: "flex",
                gap: spacing.xs
              },
              children: [confirming && /*#__PURE__*/jsxs(Fragment, {
                children: [/*#__PURE__*/jsx(ConfirmMessage$1, {
                  children: "Confirm in Wallet"
                }), /*#__PURE__*/jsx(Spinner, {
                  size: "sm",
                  color: "link"
                })]
              }), switchingFailed && /*#__PURE__*/jsx(ErrorMessage$1, {
                children: "Error: Could not Switch Network"
              })]
            })]
          }) : chainName]
        })
      }, chain.chainId);
    })
  });
});
const TabButton = styled(Tabs.Trigger)`
  all: unset;
  font-size: ${fontSize.md};
  font-weight: 500;
  color: ${p => p.theme.text.secondary};
  cursor: pointer;
  padding: ${spacing.sm} ${spacing.sm};
  -webkit-tap-highlight-color: transparent;
  border-radius: ${radius.lg};
  transition: background 0.2s ease, color 0.2s ease;
  &[data-state="active"] {
    background: ${p => p.theme.bg.elevated};
    color: ${p => p.theme.text.neutral};
  }
`;
const SectionLabel = styled.p`
  font-size: ${fontSize.sm};
  color: ${p => p.theme.text.secondary};
  margin: 0;
`;
const ScrollContainer = styled.div`
  box-sizing: border-box;
  overflow: auto;
  padding-right: 10px;
  padding-bottom: ${spacing.lg};
  width: calc(100% + 16px);
  -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  ${p => scrollbar({
  track: "transparent",
  thumb: p.theme.bg.elevated,
  hover: p.theme.bg.highlighted
})}
`;
const NetworkListUl = styled.ul`
  padding: 0;
  margin: 0;
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: ${spacing.xs};
  box-sizing: border-box;
`;
const NetworkButton = styled.button`
  all: unset;
  display: flex;
  width: 100%;
  box-sizing: border-box;
  align-items: center;
  gap: ${spacing.md};
  padding: ${spacing.sm} ${spacing.md};
  border-radius: ${radius.md};
  cursor: pointer;
  transition: background 0.2s ease;
  background: ${p => p.theme.bg.elevated};
  color: ${p => p.theme.text.neutral};
  font-weight: 600;
  font-size: ${fontSize.md};
  &:hover {
    background: ${p => p.theme.bg.highlighted};
  }

  ${media.mobile} {
    font-size: ${fontSize.sm};
  }
`;
const StyledMagnifyingGlassIcon = styled(MagnifyingGlassIcon)`
  color: ${p => p.theme.text.secondary};
  position: absolute;
  left: 18px;
`;
const SearchInput = styled(Input)`
  padding: ${spacing.sm} ${spacing.md} ${spacing.sm} 60px;
`;
const ConfirmMessage$1 = styled.div`
  font-size: ${fontSize.sm};
  color: ${p => p.theme.link.primary};
`;
const ErrorMessage$1 = styled.div`
  font-size: ${fontSize.sm};
  color: ${p => p.theme.text.danger};
`;

const ExitIcon = _ref => {
  let {
    size
  } = _ref;
  return /*#__PURE__*/jsx("svg", {
    width: size,
    height: size,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M10.79 16.29C11.18 16.68 11.81 16.68 12.2 16.29L15.79 12.7C15.8827 12.6075 15.9563 12.4976 16.0064 12.3766C16.0566 12.2557 16.0824 12.126 16.0824 11.995C16.0824 11.864 16.0566 11.7343 16.0064 11.6134C15.9563 11.4924 15.8827 11.3825 15.79 11.29L12.2 7.7C12.013 7.51302 11.7594 7.40798 11.495 7.40798C11.2306 7.40798 10.977 7.51302 10.79 7.7C10.603 7.88698 10.498 8.14057 10.498 8.405C10.498 8.66943 10.603 8.92302 10.79 9.11L12.67 11H4C3.45 11 3 11.45 3 12C3 12.55 3.45 13 4 13H12.67L10.79 14.88C10.4 15.27 10.41 15.91 10.79 16.29ZM19 3H5C4.46957 3 3.96086 3.21071 3.58579 3.58579C3.21071 3.96086 3 4.46957 3 5V8C3 8.55 3.45 9 4 9C4.55 9 5 8.55 5 8V6C5 5.45 5.45 5 6 5H18C18.55 5 19 5.45 19 6V18C19 18.55 18.55 19 18 19H6C5.45 19 5 18.55 5 18V16C5 15.45 4.55 15 4 15C3.45 15 3 15.45 3 16V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z"
    })
  });
};

const fadeInAnimation = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
const FadeIn = styled.div`
  animation: ${fadeInAnimation} 0.15s ease-in;
`;

const Flex = props => {
  return /*#__PURE__*/jsxs("div", {
    style: {
      display: "flex",
      flexDirection: props.flexDirection,
      justifyContent: props.justifyContent,
      alignItems: props.alignItems,
      gap: props.gap ? spacing[props.gap] : undefined,
      ...(props.style || {})
    },
    children: [" ", props.children]
  });
};

const FundsIcon = _ref => {
  let {
    size
  } = _ref;
  return /*#__PURE__*/jsxs("svg", {
    width: size,
    height: size,
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsx("circle", {
      cx: "6",
      cy: "6",
      r: "5.335",
      stroke: "currentColor",
      strokeWidth: "1.33"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M5.85378 8.54545V3.09091H6.20321V8.54545H5.85378ZM6.78063 4.89134C6.76358 4.71946 6.69043 4.58594 6.56117 4.49077C6.43191 4.3956 6.25648 4.34801 6.03489 4.34801C5.88432 4.34801 5.75719 4.36932 5.6535 4.41193C5.5498 4.45312 5.47026 4.51065 5.41486 4.58452C5.36088 4.65838 5.3339 4.74219 5.3339 4.83594C5.33105 4.91406 5.34739 4.98224 5.3829 5.04048C5.41983 5.09872 5.47026 5.14915 5.53418 5.19176C5.5981 5.23295 5.67196 5.26918 5.75577 5.30043C5.83958 5.33026 5.92907 5.35582 6.02424 5.37713L6.41628 5.47088C6.60662 5.51349 6.78134 5.57031 6.94043 5.64134C7.09952 5.71236 7.2373 5.79972 7.35378 5.90341C7.47026 6.0071 7.56046 6.12926 7.62438 6.26989C7.68972 6.41051 7.7231 6.57173 7.72452 6.75355C7.7231 7.0206 7.65492 7.25213 7.51998 7.44815C7.38645 7.64276 7.19327 7.79403 6.94043 7.90199C6.68901 8.00852 6.38574 8.06179 6.03063 8.06179C5.67836 8.06179 5.37154 8.00781 5.11017 7.89986C4.85023 7.7919 4.64711 7.6321 4.5008 7.42045C4.35591 7.20739 4.27992 6.94389 4.27282 6.62997H5.16557C5.17551 6.77628 5.21742 6.89844 5.29128 6.99645C5.36657 7.09304 5.46671 7.16619 5.59171 7.21591C5.71813 7.2642 5.86088 7.28835 6.01998 7.28835C6.17623 7.28835 6.31188 7.26562 6.42694 7.22017C6.54341 7.17472 6.63361 7.11151 6.69753 7.03054C6.76145 6.94957 6.79341 6.85653 6.79341 6.75142C6.79341 6.65341 6.76429 6.57102 6.70605 6.50426C6.64924 6.4375 6.56543 6.38068 6.45463 6.33381C6.34526 6.28693 6.21103 6.24432 6.05194 6.20597L5.57679 6.08665C5.2089 5.99716 4.91841 5.85724 4.70534 5.6669C4.49228 5.47656 4.38645 5.22017 4.38787 4.89773C4.38645 4.63352 4.45676 4.4027 4.59881 4.20526C4.74228 4.00781 4.93901 3.85369 5.18901 3.7429C5.43901 3.6321 5.7231 3.5767 6.04128 3.5767C6.36515 3.5767 6.64782 3.6321 6.88929 3.7429C7.13219 3.85369 7.32111 4.00781 7.45605 4.20526C7.591 4.4027 7.6606 4.63139 7.66486 4.89134H6.78063Z"
    })]
  });
};

const GenericWalletIcon = _ref => {
  let {
    size
  } = _ref;
  return /*#__PURE__*/jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: size,
    viewBox: "0 96 960 960",
    width: size,
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M652 640q25 0 44.5-19.5t19.5-45q0-25.5-19.5-44.5T652 512q-25 0-44.5 19T588 575.5q0 25.5 19.5 45T652 640ZM180 823v53-600 547Zm0 113q-23 0-41.5-18T120 876V276q0-23 18.5-41.5T180 216h600q24 0 42 18.5t18 41.5v134h-60V276H180v600h600V743h60v133q0 24-18 42t-42 18H180Zm358-173q-34 0-54-20t-20-53V463q0-34 20-53.5t54-19.5h270q34 0 54 19.5t20 53.5v227q0 33-20 53t-54 20H538Zm284-60V450H524v253h298Z"
    })
  });
};

const ModalTitle = styled(Title)`
  margin: 0;
  font-weight: 600;
  font-size: ${fontSize.lg};
  color: ${p => p.theme.text.neutral};
  text-align: left;
  ${media.mobile} {
    text-align: ${p => p.centerOnMobile ? "center" : "left"};
  }
`;
const ModalDescription = styled.p`
  all: unset;
  display: block;
  font-size: ${p => p.sm ? fontSize.sm : fontSize.md};
  color: ${p => p.theme.text.secondary};
  line-height: 1.5;
  ${media.mobile} {
    text-align: ${p => p.centerOnMobile ? "center" : "left"};
  }
`;
const BackButton = props => {
  return /*#__PURE__*/jsx(IconButton, {
    variant: "secondary",
    onClick: props.onClick,
    style: props.style,
    children: /*#__PURE__*/jsx(ChevronLeftIcon, {
      style: {
        width: iconSize.md,
        height: iconSize.md
      }
    })
  });
};
const HelperLink = styled.a`
  all: unset;
  cursor: pointer;
  color: ${p => p.theme.link.primary};
  font-size: ${fontSize.sm};
  text-decoration: none;
  display: block;
  ${media.mobile} {
    text-align: center;
  }
  &:hover {
    color: ${p => p.theme.link.primaryHover};
    text-decoration: none;
  }
`;

function useSupportedWallet(id) {
  const context = useThirdwebWallet();
  const wallet = context?.wallets.find(_wallet => _wallet.id === id);
  if (!wallet) {
    throw new Error(`Wallet with id "${id}" is not supported`);
  }
  return wallet;
}

function useDeviceWalletInfo() {
  const [walletData, setWalletData] = useState(null);
  const createWalletInstance = useCreateWalletInstance();
  const deviceWalletObj = useSupportedWallet("deviceWallet");
  const [deviceWallet, setDeviceWallet] = useState(null);
  const [storageLoading, setStorageLoading] = useState(false);
  useEffect(() => {
    const wallet = createWalletInstance(deviceWalletObj);
    setDeviceWallet(wallet);
    wallet.getSavedData().then(data => {
      setStorageLoading(false);
      setWalletData(data);
    });
  }, [createWalletInstance, deviceWalletObj]);
  return {
    deviceWallet,
    storageLoading,
    walletData,
    meta: deviceWalletObj.meta,
    refreshSavedData() {
      if (!deviceWallet) {
        return;
      }
      deviceWallet.getSavedData().then(data => {
        setStorageLoading(false);
        setWalletData(data);
      });
    }
  };
}

const DeviceWalletModalHeader = props => {
  const {
    meta
  } = useDeviceWalletInfo();
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(Img, {
      src: meta.iconURL,
      width: iconSize.xl,
      height: iconSize.xl
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    })]
  });
};

const FormFieldWithIconButton = props => {
  return /*#__PURE__*/jsxs("div", {
    children: [/*#__PURE__*/jsx(Label, {
      htmlFor: props.id,
      children: props.label
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxs(InputContainer, {
      "data-error": !!props.error,
      children: [/*#__PURE__*/jsx(Input, {
        variant: "transparent",
        required: props.required,
        name: props.name,
        autoComplete: props.autocomplete,
        id: props.id,
        onChange: e => props.onChange(e.target.value),
        value: props.value,
        type: props.type
      }), /*#__PURE__*/jsx(InputButton, {
        type: "button",
        onClick: props.right.onClick,
        children: props.right.icon
      })]
    }), props.error && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsxs(ErrorMessage$2, {
        children: [" ", props.error, " "]
      })]
    })]
  });
};
const FormField = props => {
  return /*#__PURE__*/jsxs("div", {
    children: [/*#__PURE__*/jsx(Label, {
      htmlFor: props.id,
      children: props.label
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsx(Input, {
      variant: "outline",
      required: props.required,
      name: props.name,
      autoComplete: props.autocomplete,
      id: props.id,
      onChange: e => props.onChange(e.target.value),
      value: props.value,
      type: props.type,
      "data-error": !!props.errorMessage,
      placeholder: props.placeholder,
      disabled: props.disabled
    }), props.errorMessage && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "xs"
      }), /*#__PURE__*/jsx(ErrorMessage$2, {
        children: props.errorMessage
      })]
    })]
  });
};

const ExportDeviceWallet = props => {
  const {
    deviceWallet,
    walletData
  } = useDeviceWalletInfo();
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [isWrongPassword, setIsWrongPassword] = useState(false);
  const handleDeviceWalletExport = async () => {
    if (!walletData || !deviceWallet) {
      throw new Error("invalid state");
    }
    try {
      await deviceWallet.import({
        encryptedJson: walletData.data,
        password
      });
      const json = await deviceWallet.export({
        strategy: "encryptedJson",
        password
      });
      downloadAsFile(JSON.parse(json), "wallet.json", "application/json");
      props.onExport();
    } catch (e) {
      setIsWrongPassword(true);
      return;
    }
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(DeviceWalletModalHeader, {
      onBack: props.onBack
    }), /*#__PURE__*/jsx(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Export Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(ModalDescription, {
      sm: true,
      children: "This will download a JSON file containing your wallet information onto your device encrypted with the password."
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleDeviceWalletExport();
      },
      children: [/*#__PURE__*/jsx(Label, {
        children: "Wallet Address"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(SavedWalletAddress$1, {
        children: (isMobile() ? shortenAddress(walletData?.address || "") : walletData?.address) || "Fetching..."
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: walletData?.address || "",
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
        required: true,
        name: "current-password",
        autocomplete: "current-password",
        id: "current-password",
        onChange: value => {
          setPassword(value);
          setIsWrongPassword(false);
        },
        right: {
          onClick: () => setShowPassword(!showPassword),
          icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {})
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        error: isWrongPassword ? "Wrong Password" : ""
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsx(FormFooter, {
        children: /*#__PURE__*/jsx(Button, {
          disabled: isWrongPassword,
          variant: "inverted",
          type: "submit",
          children: "Export"
        })
      })]
    })]
  });
};
function downloadAsFile(data, fileName, fileType) {
  const blob = new Blob([JSON.stringify(data, null, 2)], {
    type: fileType
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.style.display = "none";
  a.click();
  URL.revokeObjectURL(a.href);
}
const SavedWalletAddress$1 = styled.p`
  font-size: ${fontSize.md};
  color: ${props => props.theme.text.secondary};
  margin: 0;
`;

const TW_CONNECTED_WALLET = "tw-connected-wallet";
const ConnectedWalletDetails = props => {
  const disconnect = useDisconnect();
  const chains = useSupportedChains();
  const walletChainId = useChainId();
  const address = useAddress();
  const balanceQuery = useBalance();
  const activeWallet = useWallet();
  const walletContext = useThirdwebWallet();
  const [personalWalletBalance, setPersonalWalletBalance] = useState(undefined);
  const [personalWalletAddress, setPersonalWalletAddress] = useState(undefined);
  const [showExportModal, setShowExportModal] = useState(false);
  const chain = useMemo(() => {
    return chains.find(_chain => _chain.chainId === walletChainId);
  }, [walletChainId, chains]);
  const unknownChain = useMemo(() => {
    if (!chain) {
      return defaultChains.find(c => c.chainId === walletChainId);
    }
  }, [walletChainId, chain]);
  const activeWalletIconURL = activeWallet?.getMeta().iconURL || "";
  const [showNetworkSelector, setShowNetworkSelector] = useState(false);
  const [open, setOpen] = useState(false);
  const sdk = useSDK();
  const personalWallet = activeWallet?.walletId === "Safe" ? activeWallet.getPersonalWallet() // assumes using a client wallet
  : undefined;

  // get personal wallet address and balance
  useEffect(() => {
    if (!personalWallet) {
      setPersonalWalletAddress(undefined);
      setPersonalWalletBalance(undefined);
      return;
    }
    personalWallet.getAddress().then(_address => {
      setPersonalWalletAddress(_address);
    });
    personalWallet.getSigner().then(signer => {
      signer.getBalance().then(balance => {
        setPersonalWalletBalance(utils.formatEther(balance));
      });
    });
  }, [personalWallet]);
  const trigger = /*#__PURE__*/jsxs(WalletInfoButton, {
    type: "button",
    className: `${TW_CONNECTED_WALLET} ${props.className || ""}`,
    "data-theme": props.theme,
    style: props.style,
    children: [/*#__PURE__*/jsx(ChainIcon, {
      chain: chain,
      size: iconSize.lg,
      className: `${TW_CONNECTED_WALLET}__network-icon`
    }), /*#__PURE__*/jsxs(ColFlex, {
      children: [!balanceQuery.isLoading ? /*#__PURE__*/jsxs(WalletBalance, {
        className: `${TW_CONNECTED_WALLET}__balance`,
        children: [balanceQuery.data?.displayValue.slice(0, 5), " ", balanceQuery.data?.symbol]
      }) : /*#__PURE__*/jsx(Skeleton, {
        height: fontSize.sm,
        width: "82px"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xs"
      }), /*#__PURE__*/jsx(WalletAddress, {
        className: `${TW_CONNECTED_WALLET}__address`,
        children: shortenString(address || "")
      })]
    }), /*#__PURE__*/jsx(Img, {
      width: iconSize.lg,
      height: iconSize.lg,
      src: activeWalletIconURL,
      className: `${TW_CONNECTED_WALLET}__wallet-icon`
    })]
  });
  const networkSwitcherButton = /*#__PURE__*/jsxs(MenuButton, {
    id: "current-network",
    type: "button",
    disabled: activeWallet?.walletId === "Safe",
    onClick: () => {
      setOpen(false);
      setShowNetworkSelector(true);
    },
    children: [/*#__PURE__*/jsx("div", {
      style: {
        display: "flex",
        alignItems: "center",
        position: "relative"
      },
      children: /*#__PURE__*/jsx(ChainIcon, {
        chain: chain || unknownChain,
        size: iconSize.lg,
        active: true
      })
    }), chain?.name || unknownChain?.name || `Unknown chain #${walletChainId}`, /*#__PURE__*/jsx(StyledChevronRightIcon, {
      width: iconSize.sm,
      height: iconSize.sm,
      style: {
        flexShrink: 0,
        marginLeft: "auto"
      }
    })]
  });
  const switchToPersonalWallet = personalWallet && /*#__PURE__*/jsxs(MenuButton, {
    type: "button",
    onClick: () => {
      walletContext?.handleWalletConnect(personalWallet);
    },
    children: [/*#__PURE__*/jsx("div", {
      style: {
        display: "flex",
        alignItems: "center",
        position: "relative"
      },
      children: /*#__PURE__*/jsx(Img, {
        src: personalWallet.getMeta().iconURL,
        width: iconSize.lg,
        height: iconSize.lg
      })
    }), /*#__PURE__*/jsxs(ColFlex, {
      children: [personalWalletBalance ? /*#__PURE__*/jsxs(WalletBalance, {
        children: [String(personalWalletBalance).slice(0, 5), " ", balanceQuery.data?.symbol]
      }) : /*#__PURE__*/jsx(Skeleton, {
        height: fontSize.sm,
        width: "82px"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xxs"
      }), /*#__PURE__*/jsx(WalletAddress, {
        children: shortenString(personalWalletAddress || "")
      })]
    }), /*#__PURE__*/jsx(StyledChevronRightIcon, {
      width: iconSize.sm,
      height: iconSize.sm,
      style: {
        flexShrink: 0,
        marginLeft: "auto"
      }
    })]
  });
  const content = /*#__PURE__*/jsxs("div", {
    children: [/*#__PURE__*/jsxs(Flex, {
      gap: "md",
      children: [/*#__PURE__*/jsx(Img, {
        width: iconSize.xl,
        height: iconSize.xl,
        src: activeWalletIconURL,
        alt: ""
      }), /*#__PURE__*/jsxs("div", {
        style: {
          flexGrow: 1
        },
        children: [/*#__PURE__*/jsxs(Flex, {
          gap: "xs",
          alignItems: "center",
          children: [/*#__PURE__*/jsxs("div", {
            style: {
              display: "flex",
              gap: spacing.xs,
              alignItems: "center"
            },
            children: [/*#__PURE__*/jsxs(AccountAddress, {
              children: [" ", shortenString(address || "")]
            }), /*#__PURE__*/jsx(IconButton, {
              variant: "secondary",
              style: {
                padding: "3px"
              },
              children: /*#__PURE__*/jsx(CopyIcon, {
                text: address || "",
                tip: "Copy Address",
                side: "bottom"
              })
            })]
          }), /*#__PURE__*/jsx(ToolTip, {
            tip: "Disconnect Wallet",
            side: "bottom",
            align: "end",
            sideOffset: 10,
            children: /*#__PURE__*/jsx(DisconnectIconButton, {
              type: "button",
              variant: "secondary",
              onClick: () => {
                disconnect();
                props.onDisconnect();
              },
              children: /*#__PURE__*/jsx(ExitIcon, {
                size: iconSize.md
              })
            })
          })]
        }), /*#__PURE__*/jsxs(AccountBalance, {
          children: [" ", balanceQuery.data?.displayValue.slice(0, 5), " ", balanceQuery.data?.symbol, " "]
        })]
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(DropdownLabel, {
        htmlFor: "current-network",
        children: "Current Network"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), networkSwitcherButton]
    }), personalWallet && /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx(DropdownLabel, {
        htmlFor: "current-network",
        children: "Personal Wallet"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(ToolTip, {
        tip: "Switch To Personal Wallet",
        children: switchToPersonalWallet
      })]
    }), activeWallet?.walletId === "metamask" && /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsxs(MenuButton, {
        type: "button",
        onClick: () => {
          activeWallet.switchAccount();
          setOpen(false);
        },
        children: [/*#__PURE__*/jsx(ShuffleIcon, {
          width: iconSize.sm,
          height: iconSize.sm
        }), "Switch Account"]
      })]
    }), (chain?.faucets && chain.faucets.length > 0 || chain?.chainId === Localhost.chainId) && /*#__PURE__*/jsxs("div", {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsxs(MenuLink, {
        href: chain?.faucets ? chain.faucets[0] : "#",
        target: "_blank",
        as: "a",
        onClick: async e => {
          if (chain.chainId === Localhost.chainId) {
            e.preventDefault();
            setOpen(false);
            await sdk?.wallet.requestFunds(10);
            await balanceQuery.refetch();
          }
        },
        style: {
          textDecoration: "none",
          color: "inherit",
          fontSize: fontSize.sm
        },
        children: [/*#__PURE__*/jsx(SecondaryIconContainer, {
          children: /*#__PURE__*/jsx(FundsIcon, {
            size: iconSize.sm
          })
        }), "Request Testnet Funds"]
      })]
    }), activeWallet?.walletId === "deviceWallet" && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsxs(MenuButton, {
        onClick: () => {
          setShowExportModal(true);
          setOpen(false);
        },
        style: {
          fontSize: fontSize.sm
        },
        children: [/*#__PURE__*/jsx(SecondaryIconContainer, {
          children: /*#__PURE__*/jsx(GenericWalletIcon, {
            size: iconSize.sm
          })
        }), "Export Device Wallet", " "]
      })]
    })]
  });
  return /*#__PURE__*/jsxs(Fragment, {
    children: [isMobile() ? /*#__PURE__*/jsx(Modal, {
      trigger: trigger,
      open: open,
      setOpen: setOpen,
      hideCloseIcon: true,
      children: /*#__PURE__*/jsx("div", {
        style: {
          minHeight: "200px"
        },
        children: content
      })
    }) : /*#__PURE__*/jsxs(DropdownMenu.Root, {
      open: open,
      onOpenChange: setOpen,
      children: [/*#__PURE__*/jsx(DropdownMenu.Trigger, {
        asChild: true,
        children: trigger
      }), /*#__PURE__*/jsx(DropdownMenu.Portal, {
        children: /*#__PURE__*/jsx(DropDownContent, {
          asChild: true,
          side: props.dropdownPosition?.side || "bottom",
          align: props.dropdownPosition?.align || "end",
          sideOffset: 10,
          children: content
        })
      })]
    }), showNetworkSelector && /*#__PURE__*/jsx(NetworkSelector, {
      theme: props.theme,
      chains: chains,
      ...props.networkSelector,
      onClose: () => setShowNetworkSelector(false)
    }), showExportModal && /*#__PURE__*/jsx(Modal, {
      open: true,
      setOpen: setShowExportModal,
      style: {
        maxWidth: "480px"
      },
      children: /*#__PURE__*/jsx(ExportDeviceWallet, {
        onBack: () => {
          setShowExportModal(false);
        },
        onExport: () => {
          setShowExportModal(false);
        }
      })
    })]
  });
};
const dropdownContentFade = keyframes`
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
`;
const DropDownContent = styled(DropdownMenu.Content)`
  width: 360px;
  box-sizing: border-box;
  max-width: 100%;
  border-radius: ${radius.lg};
  padding: ${spacing.lg};
  animation: ${dropdownContentFade} 400ms cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  border: 1px solid ${props => props.theme.border.base};
  background-color: ${props => props.theme.bg.base};
  z-index: 1000000;
  line-height: 1;
`;
const WalletInfoButton = styled.button`
  all: unset;
  background: ${props => props.theme.bg.base};
  border: 1px solid ${props => props.theme.border.base};
  padding: ${spacing.sm} ${spacing.sm};
  border-radius: ${radius.lg};
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: ${spacing.md};
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  animation: ${fadeInAnimation} 300ms ease;

  ${media.mobile} {
    gap: ${spacing.sm};
    padding: ${spacing.xs} ${spacing.sm};
    img {
      width: ${iconSize.md}px;
      height: ${iconSize.md}px;
    }
  }

  &:hover {
    transition: background 250ms ease;
    background: ${props => props.theme.bg.baseHover};
    border-color: ${props => props.theme.bg.highlighted};
  }
`;
const WalletAddress = styled.span`
  color: ${props => props.theme.text.secondary};
  font-size: ${fontSize.xs};
  font-weight: 500;
`;
const ColFlex = styled.div`
  display: flex;
  flex-direction: column;
`;
const WalletBalance = styled.span`
  color: ${props => props.theme.text.neutral};
  font-size: ${fontSize.sm};
  font-weight: 500;
`;
const AccountAddress = styled.span`
  font-size: ${fontSize.md};
  color: ${props => props.theme.text.neutral};
  font-weight: 500;
`;
const AccountBalance = styled.span`
  font-size: ${fontSize.sm};
  color: ${props => props.theme.text.secondary};
  font-weight: 500;
`;
const DropdownLabel = styled.label`
  font-size: ${fontSize.sm};
  color: ${props => props.theme.text.secondary};
  font-weight: 500;
`;
const MenuButton = styled.button`
  all: unset;
  padding: ${spacing.sm} ${spacing.sm};
  border-radius: ${radius.md};
  background-color: ${props => props.theme.bg.base};
  border: 1px solid ${props => props.theme.border.elevated};
  box-sizing: border-box;
  display: flex;
  align-items: center;
  width: 100%;
  cursor: pointer;
  font-size: ${fontSize.md};
  font-weight: 500;
  color: ${props => props.theme.text.neutral} !important;
  gap: ${spacing.sm};
  -webkit-tap-highlight-color: transparent;
  line-height: 1.3;

  &:not([disabled]):hover {
    transition: box-shadow 250ms ease, border-color 250ms ease;
    border: 1px solid ${props => props.theme.link.primary};
    box-shadow: 0 0 0 1px ${props => props.theme.link.primary};
  }

  &[disabled] {
    cursor: not-allowed;
    svg {
      display: none;
    }
  }
`;
const MenuLink = MenuButton.withComponent("a");
styled(DropdownMenu.Item)`
  outline: none;
`;
const StyledChevronRightIcon = styled(ChevronRightIcon)`
  color: ${props => props.theme.text.secondary};
`;
const DisconnectIconButton = styled(IconButton)`
  margin-right: -${spacing.xxs};
  margin-left: auto;
  color: ${props => props.theme.icon.secondary};
  &:hover {
    color: ${props => props.theme.icon.danger};
    background: none;
  }
`;
const SecondaryIconContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  color: ${props => props.theme.icon.secondary};
`;

const SafeConnection = /*#__PURE__*/createContext(false);
const SetSafeConnection = /*#__PURE__*/createContext(undefined);
const WalletModalOpen = /*#__PURE__*/createContext(false);
const SetWalletModalOpen = /*#__PURE__*/createContext(undefined);
const ScreenContext = /*#__PURE__*/createContext("walletList");
const SetScreenContext = /*#__PURE__*/createContext(undefined);
const ModalThemeContext = /*#__PURE__*/createContext("dark");
const SetModalThemeContext = /*#__PURE__*/createContext(undefined);
const WalletUIStatesProvider = props => {
  const [isConnectingToSafe, setIsConnectingToSafe] = useState(false);
  const [isWalletModalOpen, setIsWalletModalOpen] = useState(false);
  const [screen, setScreen] = useState("walletList");
  const [modalTheme, setModalTheme] = useState(props.theme || "dark");
  return /*#__PURE__*/jsx(SafeConnection.Provider, {
    value: isConnectingToSafe,
    children: /*#__PURE__*/jsx(SetSafeConnection.Provider, {
      value: setIsConnectingToSafe,
      children: /*#__PURE__*/jsx(WalletModalOpen.Provider, {
        value: isWalletModalOpen,
        children: /*#__PURE__*/jsx(SetWalletModalOpen.Provider, {
          value: setIsWalletModalOpen,
          children: /*#__PURE__*/jsx(ScreenContext.Provider, {
            value: screen,
            children: /*#__PURE__*/jsx(SetScreenContext.Provider, {
              value: setScreen,
              children: /*#__PURE__*/jsx(ModalThemeContext.Provider, {
                value: modalTheme,
                children: /*#__PURE__*/jsx(SetModalThemeContext.Provider, {
                  value: setModalTheme,
                  children: props.children
                })
              })
            })
          })
        })
      })
    })
  });
};
const useIsConnectingToSafe = () => {
  return useContext(SafeConnection);
};
const useIsWalletModalOpen = () => {
  return useContext(WalletModalOpen);
};
const useSetIsConnectingToSafe = () => {
  const context = useContext(SetSafeConnection);
  if (context === undefined) {
    throw new Error("useSetSafeConnection must be used within a UIProvider");
  }
  return context;
};
const useSetIsWalletModalOpen = () => {
  const context = useContext(SetWalletModalOpen);
  if (context === undefined) {
    throw new Error("useSetWalletModalOpen must be used within a UIProvider");
  }
  return context;
};
const useScreen = () => {
  return useContext(ScreenContext);
};
const useSetScreen = () => {
  const context = useContext(SetScreenContext);
  if (context === undefined) {
    throw new Error("useSetScreen must be used within a UIProvider");
  }
  return context;
};
const useModalTheme = () => {
  return useContext(ModalThemeContext);
};
const useSetModalTheme = () => {
  const context = useContext(SetModalThemeContext);
  if (context === undefined) {
    throw new Error("useSetModalTheme must be used within a UIProvider");
  }
  return context;
};

const LockIcon = props => {
  return /*#__PURE__*/jsx("svg", {
    width: props.size,
    height: props.size,
    viewBox: "0 0 16 21",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsx("path", {
      d: "M2 21C1.45 21 0.979333 20.8043 0.588 20.413C0.196 20.021 0 19.55 0 19V9C0 8.45 0.196 7.979 0.588 7.587C0.979333 7.19567 1.45 7 2 7H3V5C3 3.61667 3.48767 2.43733 4.463 1.462C5.43767 0.487333 6.61667 0 8 0C9.38333 0 10.5627 0.487333 11.538 1.462C12.5127 2.43733 13 3.61667 13 5V7H14C14.55 7 15.021 7.19567 15.413 7.587C15.8043 7.979 16 8.45 16 9V19C16 19.55 15.8043 20.021 15.413 20.413C15.021 20.8043 14.55 21 14 21H2ZM8 16C8.55 16 9.021 15.8043 9.413 15.413C9.80433 15.021 10 14.55 10 14C10 13.45 9.80433 12.979 9.413 12.587C9.021 12.1957 8.55 12 8 12C7.45 12 6.97933 12.1957 6.588 12.587C6.196 12.979 6 13.45 6 14C6 14.55 6.196 15.021 6.588 15.413C6.97933 15.8043 7.45 16 8 16ZM5 7H11V5C11 4.16667 10.7083 3.45833 10.125 2.875C9.54167 2.29167 8.83333 2 8 2C7.16667 2 6.45833 2.29167 5.875 2.875C5.29167 3.45833 5 4.16667 5 5V7Z",
      fill: "currentColor"
    })
  });
};

const SignatureModal = props => {
  const wallet = useWallet();
  return /*#__PURE__*/jsx(Modal, {
    open: props.open,
    style: {
      maxWidth: "450px"
    },
    setOpen: props.setOpen,
    children: /*#__PURE__*/jsxs(Container, {
      children: [/*#__PURE__*/jsx(Img, {
        height: iconSize.xl,
        src: wallet?.getMeta().iconURL,
        width: iconSize.xl
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(TitleContainer$1, {
        children: [/*#__PURE__*/jsx(ModalTitle, {
          children: "Signature Request"
        }), /*#__PURE__*/jsx(Spinner, {
          size: "md",
          color: "link"
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsx(Desc$1, {
        children: "Sign the signature request pop-up in your wallet"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xxl"
      }), /*#__PURE__*/jsx(HelperLink, {
        target: "_blank",
        href: "https://support.thirdweb.com/contact",
        children: "Having troubles connecting to wallet"
      })]
    })
  });
};
const TitleContainer$1 = styled.div`
  display: flex;
  align-items: center;
  gap: ${spacing.sm};

  ${media.mobile} {
    justify-content: center;
    flex-direction: column;
    gap: ${spacing.md};
  }
`;
const Desc$1 = styled(ModalDescription)`
  ${media.mobile} {
    max-width: 240px;
    margin: 0 auto;
  }
`;
const Container = styled.div`
  ${media.mobile} {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
`;

const TW_CONNECT_WALLET = "tw-connect-wallet";

/**
 * A component that allows the user to connect their wallet.
 *
 * The button must be descendant of `ThirdwebProvider` in order to function.
 */
const ConnectWallet = props => {
  const activeWallet = useWallet();
  const themeFromProvider = useContext(ThirdwebThemeContext);
  const theme = props.theme || themeFromProvider || "dark";
  const isConnectingToSafe = useIsConnectingToSafe();
  const connectionStatus = useConnectionStatus();
  const isLoading = connectionStatus === "connecting" || connectionStatus === "unknown";
  const btnTitle = props.btnTitle || "Connect Wallet";
  const setIsWalletModalOpen = useSetIsWalletModalOpen();
  const setModalTheme = useSetModalTheme();
  const address = useAddress();
  const [showSignatureModal, setShowSignatureModal] = useState(false);
  const authConfig = useThirdwebAuthContext();
  const {
    user
  } = useUser();
  const {
    login
  } = useLogin();
  const {
    logout
  } = useLogout();
  const requiresSignIn = props.auth?.loginOptional ? false : !!authConfig?.authUrl && !!address && !user?.address;
  const signIn = async () => {
    try {
      setShowSignatureModal(true);
      await login(props.auth?.loginOptions);
    } catch (err) {
      console.error("failed to log in", err);
    }
    setShowSignatureModal(false);
  };
  return /*#__PURE__*/jsxs(ThemeProvider, {
    theme: theme === "dark" ? darkTheme : lightTheme,
    children: [showSignatureModal && /*#__PURE__*/jsx(SignatureModal, {
      open: showSignatureModal,
      setOpen: setShowSignatureModal
    }), requiresSignIn && /*#__PURE__*/jsxs(Button, {
      variant: "inverted",
      onClick: signIn,
      "data-theme": theme,
      className: `${TW_CONNECT_WALLET}--sign-in ${props.className || ""}}`,
      style: props.style,
      children: [/*#__PURE__*/jsxs(Flex, {
        alignItems: "center",
        gap: "sm",
        style: {
          paddingRight: spacing.xs,
          borderRight: "1px solid",
          marginRight: spacing.xs
        },
        children: [/*#__PURE__*/jsx(LockIcon, {
          size: iconSize.sm
        }), /*#__PURE__*/jsx("span", {
          children: " Sign in "
        })]
      }), /*#__PURE__*/jsx("span", {
        children: shortenAddress(address || "", true)
      })]
    }), !requiresSignIn && (!activeWallet || isConnectingToSafe ?
    /*#__PURE__*/
    // connect wallet button
    jsx(AnimatedButton, {
      disabled: isLoading,
      className: `${props.className || ""} ${TW_CONNECT_WALLET}`,
      "data-theme": theme,
      "data-is-loading": isLoading,
      variant: "inverted",
      type: "button",
      style: {
        minWidth: "140px",
        ...props.style
      },
      "aria-label": connectionStatus === "connecting" ? "Connecting" : btnTitle,
      onClick: () => {
        setModalTheme(theme);
        setIsWalletModalOpen(true);
      },
      children: isLoading ? /*#__PURE__*/jsx(Spinner, {
        size: "sm",
        color: "inverted"
      }) : btnTitle
    }) : /*#__PURE__*/jsx(ConnectedWalletDetails, {
      networkSelector: props.networkSelector,
      dropdownPosition: props.dropdownPosition,
      className: props.className,
      theme: theme,
      style: props.style,
      onDisconnect: () => {
        if (authConfig?.authUrl) {
          logout();
        }
      }
    }))]
  });
};
const AnimatedButton = styled(Button)`
  animation: ${fadeInAnimation} 300ms ease;
`;

let video;
function supportsVideoType(mimeType) {
  if (typeof window === "undefined" || !mimeType || !mimeType.startsWith("video/")) {
    return "";
  }
  if (!video) {
    video = document.createElement("video");
  }
  return video.canPlayType(mimeType);
}
function shouldRenderVideoTag(mimeType) {
  return !!supportsVideoType(mimeType);
}
let audio;
function supportsAudioType(mimeType) {
  if (typeof window === "undefined" || !mimeType || !mimeType.startsWith("audio/")) {
    return "";
  }
  if (!audio) {
    audio = document.createElement("audio");
  }
  return audio.canPlayType(mimeType);
}
function shouldRenderAudioTag(mimeType) {
  return !!supportsAudioType(mimeType);
}

function mergeRefs(refs) {
  return value => {
    refs.forEach(ref => {
      if (typeof ref === "function") {
        ref(value);
        // eslint-disable-next-line eqeqeq
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

const CarbonDocumentUnknown = props => {
  return /*#__PURE__*/jsxs("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [/*#__PURE__*/jsx("circle", {
      cx: "9",
      cy: "28.5",
      r: "1.5",
      fill: "currentColor"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z"
    })]
  });
};
const CarbonDocumentAudio = props => {
  return /*#__PURE__*/jsxs("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: [/*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z"
    })]
  });
};
const CarbonPauseFilled = props => {
  return /*#__PURE__*/jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z"
    })
  });
};
const CarbonPlayFilledAlt = props => {
  return /*#__PURE__*/jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    ...props,
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z"
    })
  });
};

const ModelViewer = /*#__PURE__*/lazy(() => import('./ModelViewer-1ba1b804.esm.js'));
const PlayButton = _ref => {
  let {
    onClick,
    isPlaying
  } = _ref;
  const [isHovering, setIsHovering] = useState(false);
  const onMouseEnter = () => setIsHovering(true);
  const onMouseLeave = () => setIsHovering(false);
  const onMouseDown = () => setIsHovering(false);
  const onMouseUp = () => setIsHovering(true);
  return /*#__PURE__*/jsx("button", {
    style: {
      position: "absolute",
      bottom: 0,
      right: 0,
      transform: "translate(-25%, -25%)",
      maxWidth: "32px",
      width: "8%",
      minWidth: "24px",
      aspectRatio: "1",
      zIndex: 3,
      backgroundColor: "#fff",
      color: "rgb(138, 147, 155)",
      display: "grid",
      placeItems: "center",
      borderRadius: "50%",
      border: "1px solid rgb(229, 232, 235)",
      cursor: "pointer",
      ...(isHovering ? {
        color: "rgb(53, 56, 64)",
        boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px"
      } : {})
    },
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onMouseDown: onMouseDown,
    onMouseUp: onMouseUp,
    children: !isPlaying ? /*#__PURE__*/jsx(CarbonPlayFilledAlt, {
      style: {
        width: "66%",
        height: "66%"
      }
    }) : /*#__PURE__*/jsx(CarbonPauseFilled, {
      style: {
        width: "66%",
        height: "66%"
      }
    })
  });
};
const VideoPlayer = /*#__PURE__*/React.forwardRef((_ref2, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    style,
    width,
    height,
    controls,
    ...restProps
  } = _ref2;
  const videoRef = useRef(null);
  const [playing, setPlaying] = useState(!requireInteraction);
  const [muted, setMuted] = useState(true);
  useEffect(() => {
    if (videoRef.current) {
      if (playing) {
        try {
          videoRef.current.play();
        } catch (err) {
          console.error("error playing video", err);
        }
      } else {
        try {
          videoRef.current.pause();
          videoRef.current.currentTime = 0;
        } catch (err) {
          console.error("error pausing video", err);
        }
      }
    }
  }, [playing]);
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [/*#__PURE__*/jsx("video", {
      ref: mergeRefs([videoRef, ref]),
      src: src ?? undefined,
      poster: poster ?? undefined,
      loop: true,
      playsInline: true,
      controlsList: "nodownload",
      muted: muted,
      preload: poster ? "metadata" : "auto",
      onCanPlay: () => {
        if (playing) {
          videoRef.current?.play();
        }
      },
      width: width,
      height: height,
      controls: controls,
      style: {
        height: "100%",
        width: "100%",
        objectFit: "contain",
        zIndex: 1,
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      }
    }), poster && /*#__PURE__*/jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt: alt
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
        setMuted(false);
      },
      isPlaying: playing
    })]
  });
});
VideoPlayer.displayName = "VideoPlayer";
const AudioPlayer = /*#__PURE__*/React.forwardRef((_ref3, ref) => {
  let {
    src,
    alt,
    poster,
    style,
    height,
    width,
    ...restProps
  } = _ref3;
  const audioRef = useRef(null);
  const [playing, setPlaying] = useState(false);
  const [muted, setMuted] = useState(true);
  useEffect(() => {
    if (audioRef.current) {
      if (playing) {
        audioRef.current.play();
      } else {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }
    }
  }, [playing]);
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [poster ? /*#__PURE__*/jsx("img", {
      height: height,
      width: width,
      src: poster,
      style: {
        height: "100%",
        width: "100%",
        pointerEvents: "none",
        objectFit: "contain"
      },
      alt: alt
    }) : /*#__PURE__*/jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        pointerEvents: "none",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /*#__PURE__*/jsx(CarbonDocumentAudio, {
        style: {
          height: "64px",
          width: "64px"
        }
      })
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
        setMuted(false);
      },
      isPlaying: playing
    }), /*#__PURE__*/jsx("audio", {
      ref: mergeRefs([audioRef, ref]),
      src: src ?? undefined,
      loop: true,
      playsInline: true,
      muted: muted,
      preload: "none",
      controlsList: "nodownload",
      style: {
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        zIndex: -1,
        visibility: "hidden"
      }
    })]
  });
});
AudioPlayer.displayName = "AudioPlayer";
const IframePlayer = /*#__PURE__*/React.forwardRef((_ref4, ref) => {
  let {
    src,
    alt,
    poster,
    requireInteraction,
    style,
    ...restProps
  } = _ref4;
  const [playing, setPlaying] = useState(!requireInteraction);
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: [/*#__PURE__*/jsx("iframe", {
      src: playing ? src ?? undefined : undefined,
      ref: ref,
      style: {
        objectFit: "contain",
        zIndex: 1,
        height: "100%",
        width: "100%",
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      },
      sandbox: "allow-scripts",
      allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    }), poster && /*#__PURE__*/jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      alt: alt
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: () => {
        setPlaying(prev => !prev);
      },
      isPlaying: playing
    })]
  });
});
IframePlayer.displayName = "IframePlayer";
const LinkPlayer = /*#__PURE__*/React.forwardRef((_ref5, ref) => {
  let {
    src,
    alt,
    style,
    ...restProps
  } = _ref5;
  return /*#__PURE__*/jsx("div", {
    style: {
      position: "relative",
      ...style
    },
    ...restProps,
    children: /*#__PURE__*/jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /*#__PURE__*/jsxs("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap"
        },
        children: [/*#__PURE__*/jsx(CarbonDocumentUnknown, {
          style: {
            maxWidth: "128px",
            minWidth: "48px",
            width: "50%",
            aspectRatio: "1"
          }
        }), /*#__PURE__*/jsx("a", {
          rel: "noopener noreferrer",
          style: {
            textDecoration: "underline",
            color: "rgb(138, 147, 155)"
          },
          href: src ?? undefined,
          target: "_blank",
          ref: ref,
          children: alt || "File"
        })]
      })
    })
  });
});
LinkPlayer.displayName = "LinkPlayer";

/**
 * This component can be used to render any media type, including image, audio, video, and html files.
 * Its convenient for rendering NFT media files, as these can be a variety of different types.
 * The component falls back to a external link if the media type is not supported.
 * The default size is 300px by 300px, but this can be changed using the `width` and `height` props.
 *
 * Props: {@link MediaRendererProps}
 *
 * @example
 * We can take a video file hosted on IPFS and render it using this component as follows
 * ```jsx
 * const Component = () => {
 *   return <MediaRenderer
 *     src="ipfs://Qmb9ZV5yznE4C4YvyJe8DVFv1LSVkebdekY6HjLVaKmHZi"
 *     alt="A mp4 video"
 *   />
 * }
 * ```
 *
 * You can try switching out the `src` prop to different types of URLs and media types to explore the possibilities.
 */
const MediaRenderer = /*#__PURE__*/React.forwardRef((_ref6, ref) => {
  let {
    src,
    poster,
    alt,
    requireInteraction = false,
    width = "300px",
    height = "300px",
    style,
    mimeType,
    ...restProps
  } = _ref6;
  const mergedStyle = {
    objectFit: "contain",
    width,
    height,
    ...style
  };
  const videoOrImageSrc = useResolvedMediaType(src ?? undefined, mimeType);
  const possiblePosterSrc = useResolvedMediaType(poster ?? undefined);
  if (!videoOrImageSrc.mimeType) {
    return /*#__PURE__*/jsx("img", {
      style: mergedStyle,
      ...restProps,
      ref: ref,
      alt: alt
    });
  } else if (videoOrImageSrc.mimeType === "text/html") {
    return /*#__PURE__*/jsx(IframePlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("model")) {
    return /*#__PURE__*/jsx(Suspense, {
      fallback: poster ? /*#__PURE__*/jsx("img", {
        style: mergedStyle,
        src: poster,
        alt: alt,
        ref: ref,
        ...restProps
      }) : null,
      children: /*#__PURE__*/jsx(ModelViewer, {
        style: mergedStyle,
        src: videoOrImageSrc.url || "",
        poster: poster,
        alt: alt,
        ...restProps
      })
    });
  } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {
    return /*#__PURE__*/jsx(VideoPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {
    return /*#__PURE__*/jsx(AudioPlayer, {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction,
      ...restProps
    });
  } else if (videoOrImageSrc.mimeType.startsWith("image/")) {
    return /*#__PURE__*/jsx("img", {
      style: mergedStyle,
      src: videoOrImageSrc.url,
      alt: alt,
      ref: ref,
      ...restProps
    });
  }
  return /*#__PURE__*/jsx(LinkPlayer, {
    style: mergedStyle,
    src: videoOrImageSrc.url,
    alt: alt,
    ref: ref,
    ...restProps
  });
});
MediaRenderer.displayName = "MediaRenderer";
/**
 * @param uri - the uri to resolve (can be a url or a ipfs://\<cid\>)
 * @returns the fully resolved url + mime type of the media
 *
 * @example
 * Usage with fully formed url:
 * ```jsx
 * const Component = () => {
 *   const resolved = useResolvedMediaType("https://example.com/video.mp4");
 *   console.log("mime type", resolved.data.mimeType);
 *   console.log("url", resolved.data.url);
 *   return null;
 * }
 * ```
 *
 * Usage with ipfs cid:
 * ```jsx
 * const Component = () => {
 *   const resolved = useResolvedMediaType("ipfs://QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvsd");
 *   console.log("mime type", resolved.data.mimeType);
 *   console.log("url", resolved.data.url);
 *   return null;
 * }
 * ```
 */
function useResolvedMediaType(uri, mimeType) {
  const resolvedUrl = useMemo(() => resolveIpfsUri(uri), [uri]);
  const resolvedMimType = useQuery(["mime-type", resolvedUrl], () => resolveMimeType(resolvedUrl), {
    enabled: !!resolvedUrl && !mimeType,
    initialData: mimeType
  });
  return {
    url: resolvedUrl,
    mimeType: resolvedMimType.data
  };
}

/**
 * This component can be used to render NFTs from the thirdweb SDK.
 * It will render the animation_url if it exists, otherwise it will render the image.
 * The default size is 300px by 300px, but this can be changed using the `width` and `height` props.
 *
 * Props: {@link ThirdwebNftMediaProps}
 *
 * @example
 * ```jsx
 * import { ThirdwebNftMedia, useContract, useNFT } from "@thirdweb-dev/react";
 * export default function NFTCollectionRender() {
 *   const { contract } = useContract(<your-contract-address>);
 *   const { data: nft, isLoading } = useNFT(contract, 0);
 *
 *   return (
 *     <div>
 *       {!isLoading && nft ? (
 *         <ThirdwebNftMedia metadata={nft.metadata} />
 *       ) : (
 *         <p>Loading...</p>
 *       )}
 *     </div>
 *   );
 * }
 * ```
 */
const ThirdwebNftMedia = /*#__PURE__*/React.forwardRef((_ref, ref) => {
  let {
    metadata,
    width = "300px",
    height = "300px",
    style,
    ...props
  } = _ref;
  return /*#__PURE__*/jsx(MediaRenderer, {
    src: metadata.animation_url || metadata.image,
    poster: metadata.image,
    alt: metadata.name?.toString() || "",
    ref: ref,
    width: width,
    height: height,
    style: {
      ...style
    },
    ...props
  });
});
ThirdwebNftMedia.displayName = "ThirdwebNftMedia";

const Popover = props => {
  return /*#__PURE__*/jsxs(RXPopover.Root, {
    open: props.open,
    onOpenChange: props.onOpenChange,
    children: [/*#__PURE__*/jsx(RXPopover.Trigger, {
      asChild: true,
      children: props.children
    }), /*#__PURE__*/jsx(RXPopover.Portal, {
      children: /*#__PURE__*/jsxs(PopoverContent, {
        sideOffset: 7,
        side: "top",
        children: [/*#__PURE__*/jsx(FlexWrapper, {
          children: props.content
        }), /*#__PURE__*/jsx(PopoverArrow, {})]
      })
    })]
  });
};
const slideUpAndFade = keyframes`
from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;
const PopoverContent = styled(RXPopover.Content)`
  border-radius: ${radius.sm};
  padding: ${spacing.sm} ${spacing.md};
  background-color: ${p => p.theme.bg.inverted};
  box-shadow: ${shadow.md};
  animation-duration: 400ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
  animation-name: ${slideUpAndFade};
  color: ${p => p.theme.text.inverted};
  font-size: ${fontSize.md};
`;
const PopoverArrow = styled(RXPopover.Arrow)`
  fill: ${p => p.theme.bg.inverted};
`;
const FlexWrapper = styled.div`
  display: flex;
  align-items: center;
  gap: ${spacing.sm};
`;

function useInstalledWallets() {
  let isMetamaskInstalled = false;
  let isCoinbaseWalletInstalled = false;
  if (assertWindowEthereum(globalThis.window)) {
    isMetamaskInstalled = globalThis.window.ethereum?.isMetaMask;
    isCoinbaseWalletInstalled = globalThis.window.ethereum?.isCoinbaseWallet || globalThis.window.ethereum?.providers?.some(p => p.isCoinbaseWallet) || false;
  }
  const installedWallets = {
    metamask: !!isMetamaskInstalled,
    coinbaseWallet: !!isCoinbaseWalletInstalled
  };
  return installedWallets;
}

/**
 *
 * @returns `true` if the wallet app is on a different device and user has connected via a QR code
 */
function useIsNonLocalWallet() {
  const activeWallet = useWallet();
  const installedWallets = useInstalledWallets();
  return activeWallet && (activeWallet.walletId === "walletConnectV1" || activeWallet.walletId === "walletConnectV2" || activeWallet.walletId === "metamask" && !installedWallets.metamask || activeWallet.walletId === "coinbaseWallet" && !installedWallets.coinbaseWallet);
}

const TW_WEB3BUTTON = "tw-web3button";
/**
 * A component that allows the user to call an on-chain function on a contract.
 *
 * The button has to be wrapped in a `ThirdwebProvider` in order to function.
 *
 * @example
 * ```javascript
 * import { Web3Button } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *  return (
 *   <div>
 *     <Web3Button contractAddress="0x..." action={(contract) => contract.erc721.transfer("0x...", 1)} />
 *   </div>
 * )
 * }
 * ```
 *
 *
 * @beta
 */
const Web3Button = _ref => {
  let {
    contractAddress,
    onSuccess,
    onError,
    onSubmit,
    isDisabled,
    contractAbi,
    children,
    action,
    className,
    type,
    theme,
    style
  } = _ref;
  const address = useAddress();
  const sdkChainId = useSDKChainId();
  const switchChain = useSwitchChain();
  const hasMismatch = useNetworkMismatch();
  const connectionStatus = useConnectionStatus();
  const queryClient = useQueryClient();
  const requiresConfirmation = useIsNonLocalWallet();
  const {
    contract
  } = useContract(contractAddress, contractAbi || "custom");
  const thirdwebTheme = useContext(ThirdwebThemeContext);
  const themeToUse = theme || thirdwebTheme || "dark";
  const [confirmStatus, setConfirmStatus] = useState("idle");
  const actionMutation = useMutation(async () => {
    invariant(contract, "contract is not ready yet");
    if (onSubmit) {
      onSubmit();
    }

    // Wait for the promise to resolve, so errors get caught by onError
    const result = await action(contract);
    return result;
  }, {
    onSuccess: res => {
      if (onSuccess) {
        onSuccess(res);
      }
    },
    onError: err => {
      if (onError) {
        onError(err);
      }
    },
    onSettled: () => queryClient.invalidateQueries()
  });
  if (!address) {
    return /*#__PURE__*/jsx(ConnectWallet, {
      style: style,
      theme: theme,
      className: `${className || ""} ${TW_WEB3BUTTON}--connect-wallet`
    });
  }

  // let onClick = () => actionMutation.mutate();

  const btnStyle = {
    minWidth: "150px",
    minHeight: "43px"
  };
  let button = null;
  const handleSwitchChain = async () => {
    if (sdkChainId) {
      setConfirmStatus("waiting");
      try {
        await switchChain(sdkChainId);
        setConfirmStatus("idle");
      } catch (e) {
        console.error(e);
        setConfirmStatus("idle");
      }
    }
  };

  // Switch Network Button
  if (hasMismatch && !isDisabled) {
    const _button = /*#__PURE__*/jsx(Button, {
      variant: "inverted",
      type: type,
      className: `${className || ""} ${TW_WEB3BUTTON}--switch-network`,
      onClick: handleSwitchChain,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": confirmStatus === "waiting",
      "data-theme": theme,
      children: confirmStatus === "waiting" ? /*#__PURE__*/jsx(Spinner, {
        size: "sm",
        color: "inverted"
      }) : "Switch Network"
    });
    if (requiresConfirmation) {
      button = /*#__PURE__*/jsx(Popover, {
        content: /*#__PURE__*/jsx("span", {
          children: "Confirm in Wallet"
        }),
        open: confirmStatus === "waiting",
        onOpenChange: isOpen => {
          if (!isOpen) {
            setConfirmStatus("idle");
          }
        },
        children: _button
      });
    } else {
      button = _button;
    }
  }

  // Disabled Loading Spinner Button
  else if (!isDisabled && (actionMutation.isLoading || !contract || connectionStatus === "connecting" || connectionStatus === "unknown")) {
    button = /*#__PURE__*/jsx(Button, {
      variant: "inverted",
      type: type,
      className: `${className || ""} ${TW_WEB3BUTTON}`,
      disabled: true,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": true,
      "data-theme": theme,
      children: /*#__PURE__*/jsx(Spinner, {
        size: "md",
        color: "inverted"
      })
    });
  }

  // action button
  else {
    button = /*#__PURE__*/jsx(Button, {
      variant: "inverted",
      type: type,
      className: `${className || ""} ${TW_WEB3BUTTON}`,
      onClick: () => actionMutation.mutate(),
      disabled: isDisabled,
      style: {
        ...btnStyle,
        ...style
      },
      "data-is-loading": "false",
      "data-theme": theme,
      children: children
    });
  }
  return /*#__PURE__*/jsx(ThemeProvider, {
    theme: themeToUse === "dark" ? darkTheme : lightTheme,
    children: button
  });
};

const DEFAULT_API_KEY = "f9e23156ccfc6173c5267eaabf320fb692ffab1c2d572095a58091cbb67590cd";

const WalletSelector = props => {
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(ModalTitle, {
      children: "Choose your wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsx(WalletSelection, {
      walletsMeta: props.walletsMeta
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsx(HelperLink, {
      as: "button",
      onClick: props.onGetStarted,
      style: {
        display: "block",
        width: "100%",
        textAlign: "center"
      },
      children: "Need help getting started?"
    })]
  });
};
const WalletSelection = props => {
  // show the installed wallets first
  const sortedWalletsMeta = props.walletsMeta.sort((a, b) => {
    if (a.installed && !b.installed) {
      return -1;
    }
    if (!a.installed && b.installed) {
      return 1;
    }
    return 0;
  });
  return /*#__PURE__*/jsx(WalletList, {
    children: sortedWalletsMeta.map(walletMeta => {
      return /*#__PURE__*/jsx("li", {
        children: /*#__PURE__*/jsxs(WalletButton, {
          type: "button",
          onClick: () => {
            walletMeta.onClick();
          },
          children: [/*#__PURE__*/jsx(Img, {
            src: walletMeta.iconURL,
            width: iconSize.lg,
            height: iconSize.lg,
            loading: "eager"
          }), /*#__PURE__*/jsx(WalletName, {
            children: walletMeta.name
          }), walletMeta.installed && /*#__PURE__*/jsx(InstallBadge, {
            children: " Installed "
          })]
        })
      }, walletMeta.id);
    })
  });
};
const WalletList = styled.ul`
  all: unset;
  list-style-type: none;
  display: flex;
  flex-direction: column;
  gap: ${spacing.xs};
  box-sizing: border-box;
`;
const WalletButton = styled.button`
  all: unset;
  padding: ${spacing.sm} ${spacing.md};
  border-radius: ${radius.sm};
  display: flex;
  align-items: center;
  gap: ${spacing.md};
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  color: ${p => p.theme.text.neutral};
  background: ${p => p.theme.bg.elevated};
  transition: 100ms ease;
  &:hover {
    background: ${p => p.theme.bg.highlighted};
  }
`;
const InstallBadge = styled.span`
  padding: ${spacing.xxs} ${spacing.xs};
  font-size: ${fontSize.xs};
  background-color: ${p => p.theme.badge.secondary};
  border-radius: ${radius.lg};
  margin-left: auto;
`;
const WalletName = styled.span`
  font-size: ${fontSize.md};
  font-weight: 500;
`;

const ConnectingScreen = props => {
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsx(IconContainer$1, {
      children: /*#__PURE__*/jsx(Img, {
        src: props.walletIconURL,
        width: iconSize.xl,
        height: iconSize.xl
      })
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs(TitleContainer, {
      children: [/*#__PURE__*/jsx(ModalTitle, {
        children: "Connecting your wallet"
      }), /*#__PURE__*/jsx(Spinner, {
        size: "md",
        color: "link"
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxs(Desc, {
      centerOnMobile: true,
      children: ["Connect your wallet through the ", props.walletName, " ", isMobile() ? "application" : "pop-up"]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsxs(HelperLink, {
      target: "_blank",
      href: props.supportLink,
      children: ["Having troubles connecting to ", props.walletName, "?"]
    })]
  });
};
const TitleContainer = styled.div`
  display: flex;
  align-items: center;
  gap: ${spacing.md};
  ${media.mobile} {
    flex-direction: column;
    align-items: center;
    gap: ${spacing.xl};
  }
`;
const IconContainer$1 = styled.div`
  display: flex;
  margin-top: ${spacing.lg};
  ${media.mobile} {
    justify-content: center;
    margin-top: 0;
  }
`;
const Desc = styled(ModalDescription)`
  ${media.mobile} {
    padding: 0 ${spacing.lg};
  }
`;

const CoinbaseWalletSetup = _ref => {
  let {
    onBack
  } = _ref;
  const coinbaseWalletObj = useSupportedWallet("coinbaseWallet");
  return /*#__PURE__*/jsx(ConnectingScreen, {
    onBack: onBack,
    walletName: coinbaseWalletObj.meta.name,
    walletIconURL: coinbaseWalletObj.meta.iconURL,
    supportLink: "https://help.coinbase.com/en/wallet/other-topics/troubleshooting-and-tips"
  });
};

const QRCode = props => {
  return /*#__PURE__*/jsxs("div", {
    style: {
      position: "relative",
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    },
    children: [props.qrCodeUri ? /*#__PURE__*/jsx(FadeIn, {
      children: /*#__PURE__*/jsx(QRCodeContainer, {
        children: /*#__PURE__*/jsx(StyledReactQrCode, {
          value: props.qrCodeUri
        })
      })
    }) : /*#__PURE__*/jsx(QRSkeleton, {
      height: "200px",
      width: "200px"
    }), props.QRIcon && /*#__PURE__*/jsx(QrCodeIconContainer, {
      children: props.QRIcon
    })]
  });
};
const QrCodeIconContainer = styled.div`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border-radius: ${radius.md};
  display: flex;
  justify-content: center;
  align-content: center;
  padding: 4px;
`;
const QRCodeContainer = styled.div`
  background: white;
  padding: ${spacing.xxs};
  display: flex;
  justify-content: center;
  align-content: center;
  border-radius: ${radius.md};
  box-shadow: ${shadow.md};
`;
const StyledReactQrCode = styled(ReactQrCode)`
  width: 200px;
  height: 200px;
  border-radius: ${radius.md};

  ${media.mobile} {
    width: 150px;
    height: 150px;
  }
`;
const QRSkeleton = styled(Skeleton)`
  width: 200px;
  height: 200px;
  border-radius: ${radius.md};
  ${media.mobile} {
    width: 150px;
    height: 150px;
  }
`;

const Apple = "ipfs://Qmcyb1akWqyu8W4DgVWzZUozrCkfES8ow36jNhjs7arwvc/AppleGray.svg";
const Chrome = "ipfs://QmPu4UKsektZixeZN4ixi8Ji9KbMuwcRKAp3JRK4jrcaMK/Chrome.svg";
const GooglePlay = "ipfs://QmTSu87iXWpfcCgy15DX3Mgp1Rqb8zFAwXdbLNh6WxmpC4/GooglePlay.svg";

const GetStartedScreen = props => {
  const [showScreen, setShowScreen] = useState("base");
  const isScanScreen = showScreen === "android-scan" || showScreen === "ios-scan";
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(BackButton, {
      style: isScanScreen ? {
        position: "absolute",
        top: spacing.lg,
        left: spacing.lg
      } : undefined,
      onClick: () => {
        if (showScreen === "base") {
          props.onBack();
        } else {
          setShowScreen("base");
        }
      }
    }), showScreen === "android-scan" && /*#__PURE__*/jsx(ScanScreen$2, {
      platformIcon: /*#__PURE__*/jsx(Img, {
        src: GooglePlay,
        width: iconSize.md,
        height: iconSize.md
      }),
      url: props.googlePlayStoreLink,
      platform: "Google Play",
      walletName: props.walletName,
      walletIconURL: props.walletIconURL
    }), showScreen === "ios-scan" && /*#__PURE__*/jsx(ScanScreen$2, {
      platformIcon: /*#__PURE__*/jsx(Img, {
        width: iconSize.md,
        height: iconSize.md,
        src: Apple
      }),
      url: props.appleStoreLink,
      platform: "App Store",
      walletName: props.walletName,
      walletIconURL: props.walletIconURL
    }), showScreen === "base" && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx(Img, {
        src: props.walletIconURL,
        width: iconSize.xl,
        height: iconSize.xl,
        alt: ""
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxs(ModalTitle, {
        children: ["Get started with ", props.walletName]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(ModalDescription, {
        children: "Download your preferred option and refresh this page"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(ButtonLink, {
        target: "_blank",
        href: props.chromeExtensionLink,
        children: [/*#__PURE__*/jsx(Img, {
          width: iconSize.lg,
          height: iconSize.lg,
          src: Chrome
        }), /*#__PURE__*/jsx("span", {
          children: "Download Chrome Extension"
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xs"
      }), /*#__PURE__*/jsxs(ButtonLink, {
        as: "button",
        target: "_blank",
        onClick: () => {
          setShowScreen("android-scan");
        },
        children: [/*#__PURE__*/jsx(Img, {
          width: iconSize.lg,
          height: iconSize.lg,
          src: GooglePlay
        }), /*#__PURE__*/jsx("span", {
          children: "Download on Google Play"
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xs"
      }), /*#__PURE__*/jsxs(ButtonLink, {
        as: "button",
        target: "_blank",
        onClick: () => {
          setShowScreen("ios-scan");
        },
        children: [/*#__PURE__*/jsx(Img, {
          width: iconSize.lg,
          height: iconSize.lg,
          src: Apple
        }), /*#__PURE__*/jsx("span", {
          children: "Download on App Store"
        })]
      })]
    }), isScanScreen && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(HelperLink, {
        as: "button",
        onClick: props.onBack,
        style: {
          textAlign: "center",
          display: "block",
          width: "100%"
        },
        children: ["I", `'`, "ve finished setting up my ", props.walletName, " on mobile"]
      })]
    })]
  });
};
const ScanScreen$2 = props => {
  return /*#__PURE__*/jsxs("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center"
    },
    children: [/*#__PURE__*/jsx(QRCode, {
      qrCodeUri: props.url,
      QRIcon: /*#__PURE__*/jsx(Img, {
        src: props.walletIconURL,
        width: iconSize.lg,
        height: iconSize.lg
      })
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsxs("div", {
      style: {
        display: "flex",
        gap: spacing.sm,
        alignItems: "center"
      },
      children: [props.platformIcon, /*#__PURE__*/jsxs(ModalTitle, {
        children: ["Install ", props.walletName, " on ", props.platform]
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs(ModalDescription, {
      children: ["Scan QR with your phone to download ", /*#__PURE__*/jsx("br", {}), " ", props.walletName, " for", " ", props.platform]
    })]
  });
};
const ButtonLink = styled.a`
  all: unset;
  text-decoration: none;
  padding: ${spacing.sm} ${spacing.md};
  border-radius: ${radius.sm};
  display: flex;
  align-items: center;
  gap: ${spacing.md};
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  color: ${p => p.theme.text.neutral};
  background: ${p => p.theme.bg.elevated};
  transition: 100ms ease;
  &:hover {
    background: ${p => p.theme.bg.highlighted};
    text-decoration: none;
    color: ${p => p.theme.text.neutral};
  }
`;

const CoinbaseGetStarted = _ref => {
  let {
    onBack
  } = _ref;
  const coinbaseWalletObj = useSupportedWallet("coinbaseWallet");
  return /*#__PURE__*/jsx(GetStartedScreen, {
    walletIconURL: coinbaseWalletObj.meta.iconURL,
    walletName: coinbaseWalletObj.meta.name,
    chromeExtensionLink: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    googlePlayStoreLink: "https://play.google.com/store/apps/details?id=org.toshi",
    appleStoreLink: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455",
    onBack: onBack
  });
};

const ScanScreen$1 = props => {
  const walletName = props.walletName.toLowerCase().includes("wallet") ? props.walletName : `${props.walletName} wallet`;
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(BackButton, {
      onClick: props.onBack,
      style: {
        position: "absolute",
        zIndex: 10,
        left: spacing.lg,
        top: spacing.lg
      }
    }), /*#__PURE__*/jsxs("div", {
      style: {
        textAlign: "center"
      },
      children: [/*#__PURE__*/jsx(QRCode, {
        qrCodeUri: props.qrCodeUri,
        QRIcon: /*#__PURE__*/jsx(Img, {
          width: iconSize.lg,
          height: iconSize.lg,
          src: props.walletIconURL
        })
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(ModalTitle, {
        style: {
          textAlign: "center"
        },
        children: ["Scan with ", walletName, " "]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsxs(ModalDescription, {
        children: ["Scan this QR code with your phone ", /*#__PURE__*/jsx("br", {}), "camera or ", walletName, " to connect"]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsx("div", {
        style: {
          display: "flex",
          justifyContent: "center"
        },
        children: /*#__PURE__*/jsx(Spinner, {
          size: "md",
          color: "link"
        })
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(LinkButton, {
        onClick: props.onGetStarted,
        children: [`Don't`, " have ", walletName, "?"]
      })]
    })]
  });
};
const LinkButton = styled.button`
  all: unset;
  color: ${p => p.theme.link.primary};
  font-size: ${fontSize.sm};
  cursor: pointer;
  &:hover {
    color: ${p => p.theme.link.primaryHover};
  }
`;

const ScanCoinbase = props => {
  const createInstance = useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = useState(undefined);
  const twWalletContext = useThirdwebWallet();
  const {
    onConnected
  } = props;
  const coinbaseWalletObj = useSupportedWallet("coinbaseWallet");
  useEffect(() => {
    if (!twWalletContext) {
      return;
    }
    (async () => {
      const wallet = createInstance(coinbaseWalletObj);
      wallet.getQrUrl().then(uri => {
        setQrCodeUri(uri || undefined);
      });
      wallet.connect({
        chainId: twWalletContext.chainToConnect?.chainId
      }).then(() => {
        twWalletContext.handleWalletConnect(wallet);
        onConnected();
      });
    })();
  }, [createInstance, twWalletContext, onConnected, coinbaseWalletObj]);
  return /*#__PURE__*/jsx(ScanScreen$1, {
    onBack: props.onBack,
    onGetStarted: props.onGetStarted,
    qrCodeUri: qrCodeUri,
    walletName: coinbaseWalletObj.meta.name,
    walletIconURL: coinbaseWalletObj.meta.iconURL
  });
};

const MetamaskConnecting = props => {
  const metamask = useSupportedWallet("metamask");
  return /*#__PURE__*/jsx(ConnectingScreen, {
    onBack: props.onBack,
    walletName: metamask.meta.name,
    walletIconURL: metamask.meta.iconURL,
    supportLink: "https://support.metamask.io/hc/en-us/articles/4406430256539-User-Guide-Troubleshooting"
  });
};

const MetamaskGetStarted = props => {
  const wallet = useSupportedWallet("metamask");
  return /*#__PURE__*/jsx(GetStartedScreen, {
    walletIconURL: wallet.meta.iconURL,
    walletName: wallet.meta.name,
    chromeExtensionLink: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    googlePlayStoreLink: "https://play.google.com/store/apps/details?id=io.metamask",
    appleStoreLink: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202",
    onBack: props.onBack
  });
};

const ScanMetamask = props => {
  const metamaskWallet = useSupportedWallet("metamask");
  const createInstance = useCreateWalletInstance();
  const [qrCodeUri, setQrCodeUri] = useState();
  const twWalletContext = useThirdwebWallet();
  const {
    onConnected
  } = props;
  useEffect(() => {
    if (!twWalletContext) {
      return;
    }
    const metamask = createInstance(metamaskWallet);
    metamask.connectWithQrCode({
      chainId: twWalletContext.chainToConnect?.chainId,
      onQrCodeUri(uri) {
        setQrCodeUri(uri);
      },
      onConnected() {
        twWalletContext.handleWalletConnect(metamask);
        onConnected();
      }
    });
  }, [createInstance, twWalletContext, onConnected, metamaskWallet]);
  return /*#__PURE__*/jsx(ScanScreen$1, {
    onBack: props.onBack,
    onGetStarted: props.onGetStarted,
    qrCodeUri: qrCodeUri,
    walletName: metamaskWallet.meta.name,
    walletIconURL: metamaskWallet.meta.iconURL
  });
};

function Steps(_ref) {
  let {
    step
  } = _ref;
  return /*#__PURE__*/jsxs(StepContainer, {
    children: [/*#__PURE__*/jsx(Circle, {
      "data-active": true
    }), /*#__PURE__*/jsx(Line, {
      "data-active": step === 2
    }), /*#__PURE__*/jsx(Circle, {
      "data-active": step === 2
    })]
  });
}
const StepContainer = styled.div`
  display: flex;
  align-items: center;
  width: 130px;
  padding: ${spacing.xs};
`;
const Circle = styled.div`
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background-color: ${p => p.theme.bg.highlighted};
  box-shadow: 0 0 0 3px ${p => p.theme.bg.base},
    0 0 0 5px ${p => p.theme.bg.highlighted};

  &[data-active="true"] {
    background-color: ${p => p.theme.link.primary};
    box-shadow: 0 0 0 3px ${p => p.theme.bg.base},
      0 0 0 5px ${p => p.theme.link.primary};

    position: relative;
    z-index: 2;
  }
`;
const Line = styled.div`
  flex-grow: 1;
  height: 4px;
  background-color: ${p => p.theme.bg.highlighted};
  &[data-active="true"] {
    background-color: ${p => p.theme.link.primary};
  }
`;

const SelectpersonalWallet = props => {
  const safeWalletObj = useSupportedWallet("Safe");
  // remove gnosis safe from the list of wallets
  const walletsMeta = props.walletsMeta.filter(w => w.id !== "Safe");
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsx(IconContainer, {
      children: /*#__PURE__*/jsx(Img, {
        src: safeWalletObj.meta.iconURL,
        width: iconSize.xl,
        height: iconSize.xl
      })
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(ModalTitle, {
      children: "Choose your Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsx(ModalDescription, {
      children: "Select a personal wallet to connect to your Safe"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsx(Steps, {
      step: 1
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(WalletSelection, {
      walletsMeta: walletsMeta
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsx(HelperLink, {
      target: "_blank",
      href: "https://docs.safe.global/learn/what-is-a-smart-contract-account",
      style: {
        textAlign: "center"
      },
      children: "What is a Safe?"
    })]
  });
};
const IconContainer = styled.div`
  margin-top: ${spacing.lg};
`;

const gnosisAddressPrefixToChainId = {
  eth: 1,
  matic: 137,
  avax: 43114,
  bnb: 56,
  oeth: 10,
  gor: 5
};
const SafeForm = props => {
  const safeWalletObj = useSupportedWallet("Safe");
  const activeWallet = useWallet();
  const connect = useConnect();
  const activeChain = useActiveChain();
  const connectedChainId = useChainId();
  const [safeAddress, setSafeAddress] = useState("");
  const [safeChainId, setSafeChainId] = useState(-1);
  const [safeConnectError, setSafeConnectError] = useState(false);
  const [switchError, setSwitchError] = useState(false);
  const [switchingNetwork, setSwitchingNetwork] = useState(false);
  const connectionStatus = useConnectionStatus();
  const requiresConfirmation = useIsNonLocalWallet();
  const chains = useSupportedChains();

  // put supported chains first
  const supportedChains = chains.filter(c => SafeSupportedChainsSet.has(c.chainId));
  const selectedSafeChain = supportedChains.find(c => c.chainId === safeChainId);
  const testnets = supportedChains.filter(c => c.testnet);
  const mainnets = supportedChains.filter(c => !c.testnet);

  // if there are more than one mainnet and testnet, group them
  const useOptGroup = mainnets.length > 0 && testnets.length > 0;
  const handleSubmit = async () => {
    if (!selectedSafeChain || !activeWallet || !activeChain) {
      return;
    }
    setSafeConnectError(false);
    try {
      await connect(safeWalletObj, {
        chain: selectedSafeChain,
        personalWallet: activeWallet,
        safeAddress
      });
      props.onConnect();
    } catch (e) {
      console.error(e);
      setSafeConnectError(true);
    }
  };
  const mismatch = safeChainId !== -1 && connectedChainId !== safeChainId;
  const isValidAddress = utils.isAddress(safeAddress);
  const disableNetworkSelection = supportedChains.length === 1;
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(Img, {
      src: safeWalletObj.meta.iconURL,
      width: iconSize.xl,
      height: iconSize.xl
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(ModalTitle, {
      children: "Enter your Safe Address & Network "
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxs(ModalDescription, {
      children: ["You can find your safe address in", " ", /*#__PURE__*/jsx(HelperLink, {
        target: "_blank",
        href: "https://app.safe.global/home",
        style: {
          display: "inline"
        },
        children: "Safe Dashboard"
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(Steps, {
      step: 2
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleSubmit();
      },
      children: [/*#__PURE__*/jsx(FormField, {
        name: "safeAddress",
        id: "safeAddress",
        errorMessage: safeAddress && !isValidAddress ? "Invalid Safe Address" : undefined,
        autocomplete: "on",
        onChange: value => {
          setSafeConnectError(false);
          if (value.length > 4) {
            const prefix = value.split(":")[0];
            if (prefix && prefix in gnosisAddressPrefixToChainId) {
              setSafeChainId(gnosisAddressPrefixToChainId[prefix]);
              setSafeAddress(value.slice(prefix.length + 1));
            } else {
              setSafeAddress(value);
            }
          } else {
            setSafeAddress(value);
          }
        },
        label: "Safe Address",
        type: "text",
        value: safeAddress,
        required: true,
        placeholder: "0x123..."
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx(Label, {
        htmlFor: "safeNetwork",
        children: "Safe Network"
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xs"
      }), /*#__PURE__*/jsxs("div", {
        style: {
          position: "relative"
        },
        children: [/*#__PURE__*/jsxs(NetworkSelect, {
          "data-error": supportedChains.length === 0,
          required: true,
          name: "safeNetwork",
          id: "safeNetwork",
          value: safeChainId,
          disabled: disableNetworkSelection,
          placeholder: "Select Network your safe is deployed to",
          onChange: e => {
            setSafeConnectError(false);
            setSwitchError(false);
            setSafeChainId(Number(e.target.value));
          },
          children: [!disableNetworkSelection && /*#__PURE__*/jsx("option", {
            value: "",
            hidden: true,
            children: "Select network your safe is deployed on"
          }), useOptGroup ? /*#__PURE__*/jsxs(Fragment, {
            children: [/*#__PURE__*/jsx("optgroup", {
              label: "Mainnets",
              children: mainnets.map(chain => {
                return /*#__PURE__*/jsx("option", {
                  value: chain.chainId,
                  children: chain.name
                }, chain.chainId);
              })
            }), /*#__PURE__*/jsx("optgroup", {
              label: "Testnets",
              children: testnets.map(chain => {
                return /*#__PURE__*/jsx("option", {
                  value: chain.chainId,
                  children: chain.name
                }, chain.chainId);
              })
            })]
          }) : supportedChains.map(chain => {
            return /*#__PURE__*/jsx("option", {
              value: chain.chainId,
              children: chain.name
            }, chain.chainId);
          })]
        }), !disableNetworkSelection && /*#__PURE__*/jsx(ChevronDownIcon, {
          width: iconSize.sm,
          height: iconSize.sm,
          style: {
            position: "absolute",
            top: "50%",
            right: spacing.sm,
            transform: "translateY(-50%)",
            pointerEvents: "none"
          }
        })]
      }), supportedChains.length === 0 && /*#__PURE__*/jsxs(Fragment, {
        children: [/*#__PURE__*/jsx(Spacer, {
          y: "sm"
        }), /*#__PURE__*/jsxs(ErrorMessage$2, {
          children: [" ", "Can not use Safe: No Safe supported chains are configured in App"]
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), safeConnectError && /*#__PURE__*/jsxs(ErrorMessage$2, {
        style: {
          display: "flex",
          gap: spacing.sm,
          alignItems: "center",
          fontSize: fontSize.sm
        },
        children: [/*#__PURE__*/jsx(ExclamationTriangleIcon, {
          width: iconSize.sm,
          height: iconSize.sm
        }), /*#__PURE__*/jsxs("span", {
          children: ["Could not connect to Safe. ", /*#__PURE__*/jsx("br", {}), "Make sure safe address and network are correct."]
        })]
      }), switchError && /*#__PURE__*/jsxs(ErrorMessage$2, {
        style: {
          display: "flex",
          gap: spacing.sm,
          alignItems: "center",
          fontSize: fontSize.sm
        },
        children: [/*#__PURE__*/jsx(ExclamationTriangleIcon, {
          width: iconSize.sm,
          height: iconSize.sm
        }), /*#__PURE__*/jsx("span", {
          children: "Failed to switch network."
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsx("div", {
        style: {
          display: "flex",
          justifyContent: "flex-end"
        },
        children: mismatch ? /*#__PURE__*/jsxs(Button, {
          type: "button",
          variant: "secondary",
          style: {
            display: "flex",
            alignItems: "center",
            gap: spacing.sm
          },
          onClick: async () => {
            if (!activeWallet) {
              throw new Error("No active wallet");
            }
            setSafeConnectError(false);
            setSwitchError(false);
            setSwitchingNetwork(true);
            try {
              await activeWallet.switchChain(safeChainId);
            } catch (e) {
              setSwitchError(true);
            } finally {
              setSwitchingNetwork(false);
            }
          },
          children: [" ", switchingNetwork ? "Switching" : "Switch Network", switchingNetwork && /*#__PURE__*/jsx(Spinner, {
            size: "sm",
            color: "primary"
          })]
        }) : /*#__PURE__*/jsxs(Button, {
          variant: "inverted",
          type: "submit",
          style: {
            display: "flex",
            alignItems: "center",
            gap: spacing.sm
          },
          children: [connectionStatus === "connecting" ? "Connecting" : "Connect to Safe", connectionStatus === "connecting" && /*#__PURE__*/jsx(Spinner, {
            size: "sm",
            color: "inverted"
          })]
        })
      }), switchingNetwork && requiresConfirmation && /*#__PURE__*/jsx(ConfirmMessage, {
        children: " Confirm in your wallet "
      })]
    })]
  });
};
const ConfirmMessage = styled.p`
  font-size: ${fontSize.sm};
  color: ${p => p.theme.link.primary};
  text-align: right;
`;
const NetworkSelect = styled.select`
  width: 100%;
  padding: ${spacing.sm};
  box-sizing: border-box;
  outline: none;
  border: none;
  border-radius: 6px;
  color: ${p => p.theme.text.neutral};
  background: transparent;
  font-size: ${fontSize.md};
  box-shadow: 0 0 0 1.5px ${p => p.theme.input.outline};
  appearance: none;

  &:focus {
    box-shadow: 0 0 0 2px ${p => p.theme.input.focusRing};
  }

  &:invalid {
    color: ${p => p.theme.text.secondary};
  }
  &[data-error="true"] {
    box-shadow: 0 0 0 1.5px ${p => p.theme.input.errorRing};
  }

  &[disabled] {
    opacity: 1;
    cursor: not-allowed;
  }
`;

const walletName = MetaMaskWallet.meta.name;
const walletIconURL = MetaMaskWallet.meta.iconURL;
const chromeExtensionLink = "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn";
const googlePlayStoreLink = "https://play.google.com/store/apps/details?id=io.metamask";
const appleStoreLink = "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202";
const GetStartedWithWallets = props => {
  const [showScreen, setShowScreen] = useState("base");
  const isScanScreen = showScreen === "android-scan" || showScreen === "ios-scan";
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(BackButton, {
      style: isScanScreen ? {
        position: "absolute",
        top: spacing.lg,
        left: spacing.lg
      } : undefined,
      onClick: () => {
        if (showScreen === "base") {
          props.onBack();
        } else {
          setShowScreen("base");
        }
      }
    }), showScreen === "android-scan" && /*#__PURE__*/jsx(ScanScreen, {
      platformIcon: /*#__PURE__*/jsx(Img, {
        src: GooglePlay,
        width: iconSize.md,
        height: iconSize.md
      }),
      url: googlePlayStoreLink,
      platform: "Google Play",
      walletName: walletName,
      walletIconURL: walletIconURL
    }), showScreen === "ios-scan" && /*#__PURE__*/jsx(ScanScreen, {
      platformIcon: /*#__PURE__*/jsx(Img, {
        src: Apple,
        width: iconSize.md,
        height: iconSize.md
      }),
      url: appleStoreLink,
      platform: "App Store",
      walletName: walletName,
      walletIconURL: walletIconURL
    }), showScreen === "base" && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx(ModalTitle, {
        children: " Get started with EVM wallets "
      }), /*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsx(ModalDescription, {
        children: "An EVM Wallet is your gateway to interact with web3 apps on Ethereum and other custom blockchains."
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs("div", {
        style: {
          display: "flex",
          gap: spacing.md,
          alignItems: "center"
        },
        children: [/*#__PURE__*/jsx(SecondaryText, {
          children: "We recommend"
        }), /*#__PURE__*/jsxs("div", {
          style: {
            display: "flex",
            gap: spacing.xs,
            alignItems: "center"
          },
          children: [/*#__PURE__*/jsx(Img, {
            src: walletIconURL,
            width: iconSize.md,
            height: iconSize.md
          }), /*#__PURE__*/jsx(NeutralText, {
            children: "MetaMask"
          })]
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "md"
      }), /*#__PURE__*/jsxs("div", {
        children: [/*#__PURE__*/jsxs(ButtonLink, {
          target: "_blank",
          href: chromeExtensionLink,
          children: [/*#__PURE__*/jsx(Img, {
            src: Chrome,
            width: iconSize.lg,
            height: iconSize.lg
          }), /*#__PURE__*/jsx("span", {
            children: "Download Chrome Extension"
          })]
        }), /*#__PURE__*/jsx(Spacer, {
          y: "xs"
        }), /*#__PURE__*/jsxs(ButtonLink, {
          as: "button",
          target: "_blank",
          onClick: () => {
            if (isMobile()) {
              window.open(googlePlayStoreLink, "_blank");
            } else {
              setShowScreen("android-scan");
            }
          },
          children: [/*#__PURE__*/jsx(Img, {
            src: GooglePlay,
            width: iconSize.lg,
            height: iconSize.lg
          }), /*#__PURE__*/jsx("span", {
            children: "Download on Google Play"
          })]
        }), /*#__PURE__*/jsx(Spacer, {
          y: "xs"
        }), /*#__PURE__*/jsxs(ButtonLink, {
          as: "button",
          target: "_blank",
          onClick: () => {
            if (isMobile()) {
              window.open(appleStoreLink, "_blank");
            } else {
              setShowScreen("ios-scan");
            }
          },
          children: [/*#__PURE__*/jsx(Img, {
            src: Apple,
            width: iconSize.lg,
            height: iconSize.lg
          }), /*#__PURE__*/jsx("span", {
            children: "Download on App Store"
          })]
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsx(HelperLink, {
        target: "_blank",
        href: "https://ethereum.org/en/wallets/find-wallet/",
        style: {
          textAlign: "center"
        },
        children: "Learn more about wallets"
      })]
    }), isScanScreen && /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxs(HelperLink, {
        as: "button",
        onClick: props.onBack,
        style: {
          textAlign: "center",
          display: "block",
          width: "100%"
        },
        children: ["I", `'`, "ve finished setting up my ", walletName, " mobile wallet"]
      })]
    })]
  });
};
const ScanScreen = props => {
  return /*#__PURE__*/jsxs("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center"
    },
    children: [/*#__PURE__*/jsx(QRCode, {
      qrCodeUri: props.url,
      QRIcon: /*#__PURE__*/jsx(Img, {
        src: props.walletIconURL,
        width: iconSize.lg,
        height: iconSize.lg
      })
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsxs("div", {
      style: {
        display: "flex",
        gap: spacing.sm,
        alignItems: "center"
      },
      children: [props.platformIcon, /*#__PURE__*/jsxs(ModalTitle, {
        style: {
          fontSize: fontSize.xl
        },
        children: ["Install ", props.walletName, " for ", props.platform]
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs(ModalDescription, {
      children: ["Scan QR with your phone to download ", /*#__PURE__*/jsx("br", {}), " ", props.walletName, " for", " ", props.platform]
    })]
  });
};
const SecondaryText = styled.p`
  font-size: ${fontSize.md};
  color: ${p => p.theme.text.secondary};
  margin: 0;
`;
const NeutralText = styled.p`
  font-size: ${fontSize.md};
  color: ${p => p.theme.text.neutral};
  margin: 0;
`;

/**
 * if the `options.for` promise takes longer than the `options.moreThan` time, `options.do` callback function will be called
 *
 * this is useful to prevent showing the loading animation for a super short time that looks like flickering
 * @param options
 */
async function ifWaiting(options) {
  const id = setTimeout(options.do, options.moreThan);
  await options.for;
  clearTimeout(id);
}

const RemoveWallet = props => {
  const [showExport, setShowExport] = useState(false);
  const [isExported, setIsExported] = useState(false);
  if (showExport) {
    return /*#__PURE__*/jsx(ExportDeviceWallet, {
      onBack: () => {
        setShowExport(false);
      },
      onExport: () => {
        setIsExported(true);
        setShowExport(false);
      }
    });
  }
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(DeviceWalletModalHeader, {
      onBack: props.onBack
    }), /*#__PURE__*/jsxs(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: ["Remove Wallet ", shortenAddress(props.address || "")]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), isExported ? /*#__PURE__*/jsxs(Flex, {
      gap: "sm",
      alignItems: "center",
      children: [/*#__PURE__*/jsx(CheckCircledIcon, {
        width: iconSize.md,
        height: iconSize.md,
        style: {
          flexShrink: 0
        },
        color: green.green8
      }), /*#__PURE__*/jsx(ModalDescription, {
        children: "Wallet JSON file is downloaded to your device, You can now remove it safely."
      })]
    }) : /*#__PURE__*/jsxs(ModalDescription, {
      children: ["Removing this saved wallet cannot be reverted. To ensure you have a backup", " ", /*#__PURE__*/jsx(HelperLink, {
        as: "button",
        onClick: () => {
          setShowExport(true);
        },
        style: {
          display: "inline"
        },
        children: "Export your wallet"
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsx(FormFooter, {
      children: /*#__PURE__*/jsx(Button, {
        variant: "danger",
        onClick: props.onRemove,
        children: "Remove"
      })
    })]
  });
};

const ReconnectDeviceWallet = props => {
  const {
    walletData,
    deviceWallet
  } = useDeviceWalletInfo();
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [isWrongPassword, setIsWrongPassword] = useState(false);
  const thirdwebWalletContext = useThirdwebWallet();
  const [isConnecting, setIsConnecting] = useState(false);
  const [showRemoveConfirmation, setShowRemoveConfirmation] = useState(false);
  const handleRemove = async () => {
    if (!deviceWallet) {
      throw new Error("Invalid state");
    }
    await deviceWallet?.deleteSaved();
    props.onRemove();
  };
  if (showRemoveConfirmation) {
    return /*#__PURE__*/jsx(RemoveWallet, {
      onRemove: handleRemove,
      address: shortenAddress(walletData?.address || ""),
      onBack: () => {
        setShowRemoveConfirmation(false);
      }
    });
  }
  const handleReconnect = async () => {
    if (!deviceWallet || !thirdwebWalletContext) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    try {
      await deviceWallet.load({
        strategy: "encryptedJson",
        password
      });
      await deviceWallet.connect();
      thirdwebWalletContext.handleWalletConnect(deviceWallet);
      props.onConnected();
    } catch (e) {
      setIsWrongPassword(true);
    }
    setIsConnecting(false);
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(DeviceWalletModalHeader, {
      onBack: props.onBack
    }), /*#__PURE__*/jsx(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Device Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xs"
    }), /*#__PURE__*/jsx(ModalDescription, {
      children: "Connect to saved wallet on your device"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xl"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleReconnect();
      },
      children: [/*#__PURE__*/jsxs(Flex, {
        alignItems: "center",
        gap: "xs",
        children: [/*#__PURE__*/jsx(Label, {
          children: "Saved Wallet"
        }), /*#__PURE__*/jsx(ToolTip, {
          tip: "Remove Wallet",
          sideOffset: 7,
          children: /*#__PURE__*/jsx(IconButton, {
            variant: "secondary",
            type: "button",
            onClick: () => {
              setShowRemoveConfirmation(true);
            },
            children: /*#__PURE__*/jsx(RedCircle, {
              width: iconSize.sm,
              height: iconSize.sm
            })
          })
        })]
      }), /*#__PURE__*/jsx(Spacer, {
        y: "sm"
      }), /*#__PURE__*/jsx(SavedWalletAddress, {
        children: (isMobile() ? shortenAddress(walletData?.address || "") : walletData?.address) || "Fetching..."
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: walletData?.address || "",
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
        required: true,
        name: "current-password",
        autocomplete: "current-password",
        id: "current-password",
        onChange: value => {
          setPassword(value);
          setIsWrongPassword(false);
        },
        right: {
          onClick: () => setShowPassword(!showPassword),
          icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {})
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        error: isWrongPassword ? "Wrong Password" : ""
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsx(FormFooter, {
        children: /*#__PURE__*/jsxs(Button, {
          variant: "inverted",
          type: "submit",
          style: {
            display: "flex",
            gap: spacing.sm
          },
          children: ["Connect", isConnecting && /*#__PURE__*/jsx(Spinner, {
            size: "sm",
            color: "inverted"
          })]
        })
      })]
    })]
  });
};
const SavedWalletAddress = styled.p`
  font-size: ${fontSize.md};
  color: ${props => props.theme.text.secondary};
  margin: 0;
`;
const RedCircle = styled(CrossCircledIcon)`
  color: ${props => props.theme.input.errorRing};
`;

const DragNDrop = props => {
  const [error, setError] = useState(false);
  const [uploaded, setUploaded] = useState();
  const [isDragging, setIsDragging] = useState(false);
  const dragIn = e => {
    setError(false);
    setUploaded(undefined);
    setIsDragging(true);
    e.preventDefault();
    e.stopPropagation();
  };
  const dragOut = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
  };
  const handleFileUpload = file => {
    if (file.type !== props.accept) {
      setError(true);
    } else {
      setUploaded(file);
      props.onUpload(file);
    }
  };
  const drop = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFileUpload(e.dataTransfer.files[0]);
      e.dataTransfer.clearData();
    }
  };
  const message = isMobile() ? "Click to Upload" : "Drop your file here or click to upload";
  return /*#__PURE__*/jsx("div", {
    onDragEnter: dragIn,
    onDragLeave: dragOut,
    onDragOver: e => {
      setIsDragging(true);
      e.preventDefault();
      e.stopPropagation();
    },
    onClick: () => {
      setError(false);
    },
    onDrop: drop,
    style: {
      cursor: "pointer"
    },
    children: /*#__PURE__*/jsxs("label", {
      htmlFor: "file-upload",
      children: [/*#__PURE__*/jsx("input", {
        id: "file-upload",
        type: "file",
        accept: props.accept,
        multiple: false,
        style: {
          display: "none"
        },
        onChange: e => {
          if (e.target.files && e.target.files.length > 0) {
            handleFileUpload(e.target.files[0]);
          }
        }
      }), /*#__PURE__*/jsx(DropContainer, {
        "data-error": error,
        "data-is-dragging": isDragging,
        children: !uploaded ? /*#__PURE__*/jsxs(Fragment, {
          children: [" ", /*#__PURE__*/jsx(UploadIconSecondary, {
            width: iconSize.xl,
            height: iconSize.xl
          }), /*#__PURE__*/jsx(Spacer, {
            y: "md"
          }), /*#__PURE__*/jsx(Message, {
            children: message
          }), /*#__PURE__*/jsx(Spacer, {
            y: "md"
          }), error ? /*#__PURE__*/jsxs(ErrorMessage, {
            children: [" ", "Please upload a ", props.extension, " file", " "]
          }) : /*#__PURE__*/jsxs(ExtensionText, {
            children: [" ", props.extension, " "]
          })]
        }) : /*#__PURE__*/jsxs(Fragment, {
          children: [/*#__PURE__*/jsxs(Message, {
            children: [uploaded.name, " uploaded successfully"]
          }), /*#__PURE__*/jsx(Spacer, {
            y: "md"
          }), /*#__PURE__*/jsx(CheckCircleIcon, {
            size: iconSize.xl
          })]
        })
      })]
    })
  });
};
const UploadIconSecondary = styled(UploadIcon)`
  color: ${props => props.theme.text.secondary};
  transition: transform 200ms ease, color 200ms ease;
`;
const DropContainer = styled.div`
  border: 2px solid ${p => p.theme.bg.elevated};
  border-radius: ${radius.md};
  padding: ${spacing.xl} ${spacing.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${p => p.theme.link.primary};
    svg {
      color: ${p => p.theme.link.primary};
      transform: translateY(-8px);
    }
  }

  &[data-error="true"] {
    border-color: ${p => p.theme.input.errorRing};
  }
`;
const ErrorMessage = styled.p`
  color: ${p => p.theme.input.errorRing};
  font-size: ${fontSize.sm};
  margin: 0;
`;
const ExtensionText = styled.span`
  color: ${p => p.theme.text.secondary};
  font-size: ${fontSize.sm};
`;
const CheckCircleIcon = props => /*#__PURE__*/jsxs("svg", {
  width: props.size,
  height: props.size,
  viewBox: "0 0 38 38",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [/*#__PURE__*/jsx("path", {
    d: "M35.6666 17.4671V19.0004C35.6645 22.5945 34.5008 26.0916 32.3488 28.9701C30.1969 31.8487 27.1721 33.9546 23.7255 34.9736C20.279 35.9926 16.5954 35.8703 13.224 34.6247C9.85272 33.3792 6.97434 31.0773 5.01819 28.0622C3.06203 25.0472 2.1329 21.4805 2.36938 17.8943C2.60586 14.308 3.99526 10.8943 6.33039 8.16221C8.66551 5.43012 11.8212 3.52606 15.3269 2.734C18.8326 1.94194 22.5004 2.30432 25.7833 3.76709",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/jsx("path", {
    d: "M35.6667 5.66699L19 22.3503L14 17.3503",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
});
const Message = styled.p`
  color: ${p => p.theme.text.neutral};
  font-size: ${fontSize.md};
  margin: 0;
  font-weight: 600;
`;

const ImportDeviceWalet = props => {
  const [jsonString, setJsonString] = useState();
  const {
    deviceWallet
  } = useDeviceWalletInfo();
  const [password, setPassword] = useState("");
  const [isWrongPassword, setIsWrongPassword] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [importedAddress, setImportedAddress] = useState();
  const thirdwebWalletContext = useThirdwebWallet();
  const handleImport = async () => {
    if (!deviceWallet || !jsonString || !thirdwebWalletContext) {
      throw new Error("Invalid state");
    }
    try {
      await deviceWallet.import({
        encryptedJson: jsonString,
        password
      });
      await deviceWallet.save({
        strategy: "encryptedJson",
        password
      });
      thirdwebWalletContext.handleWalletConnect(deviceWallet);
      props.onConnected();
    } catch (e) {
      setIsWrongPassword(true);
      return;
    }
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(DeviceWalletModalHeader, {
      onBack: props.onBack
    }), /*#__PURE__*/jsx(ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Import JSON Wallet"
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      gap: "sm",
      children: [!isMobile() && /*#__PURE__*/jsx(WarningIcon, {
        width: iconSize.md,
        height: iconSize.md,
        style: {
          flexShrink: 0
        }
      }), /*#__PURE__*/jsx(ModalDescription, {
        sm: true,
        children: "The application can authorize any transactions on behalf of the wallet without any approvals. We recommend only connecting to trusted applications."
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "md"
    }), /*#__PURE__*/jsx(DragNDrop, {
      extension: "JSON",
      accept: "application/json",
      onUpload: file => {
        const reader = new FileReader();
        reader.onload = event => {
          setJsonString(event.target?.result);
          const obj = JSON.parse(event.target?.result);
          setImportedAddress(obj.address);
        };
        reader.readAsText(file, "utf-8");
      }
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleImport();
      },
      children: [jsonString && /*#__PURE__*/jsxs(Fragment, {
        children: [/*#__PURE__*/jsx("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: importedAddress || "",
          disabled: true,
          style: {
            display: "none"
          }
        }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
          required: true,
          name: "current-password",
          autocomplete: "current-password",
          id: "current-password",
          onChange: value => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {})
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : ""
        }), /*#__PURE__*/jsx(Spacer, {
          y: "xl"
        })]
      }), /*#__PURE__*/jsx(FormFooter, {
        children: /*#__PURE__*/jsx(Button, {
          variant: "inverted",
          type: "submit",
          disabled: !jsonString,
          style: {
            minWidth: "110px",
            opacity: jsonString ? 1 : 0.5
          },
          children: "Import"
        })
      })]
    })]
  });
};
const WarningIcon = styled(InfoCircledIcon)`
  color: ${p => p.theme.icon.danger};
`;

const CreateDeviceWallet = props => {
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const passwordMismatch = confirmPassword && password !== confirmPassword;
  const {
    deviceWallet
  } = useDeviceWalletInfo();
  const thirdwebWalletContext = useThirdwebWallet();
  const [showImportScreen, setShowImportScreen] = useState(false);
  const [generatedAddress, setGeneratedAddress] = useState(null);
  const isGenerated = useRef(false);
  useEffect(() => {
    if (!deviceWallet || showImportScreen) {
      return;
    }
    isGenerated.current = true;
    deviceWallet.generate().then(_address => {
      setGeneratedAddress(_address);
    });
  }, [deviceWallet, showImportScreen]);
  if (showImportScreen) {
    return /*#__PURE__*/jsx(ImportDeviceWalet, {
      onConnected: props.onConnected,
      onBack: () => {
        setShowImportScreen(false);
      }
    });
  }
  const handleConnect = async () => {
    if (passwordMismatch || !deviceWallet || !thirdwebWalletContext) {
      throw new Error("Invalid state");
    }
    deviceWallet.connect();
    await deviceWallet.save({
      strategy: "encryptedJson",
      password
    });
    thirdwebWalletContext.handleWalletConnect(deviceWallet);
    props.onConnected();
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(DeviceWalletModalHeader, {
      onBack: props.onBack
    }), /*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      gap: "xs",
      children: [/*#__PURE__*/jsx(ModalTitle, {
        children: "Choose a password"
      }), !isMobile() && /*#__PURE__*/jsx(ToolTip, {
        tip: "The application can authorize any transactions on behalf of the wallet without any approvals. We recommend only connecting to trusted applications.",
        children: /*#__PURE__*/jsx(InfoCircledIconSecondary, {
          width: iconSize.md,
          height: iconSize.md
        })
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxs(ModalDescription, {
      sm: true,
      children: ["Enter a password and we", `'`, "ll create a wallet for you. You", `'`, "ll be able to access and export this wallet with the same password."]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleConnect();
      },
      children: [/*#__PURE__*/jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: generatedAddress || "",
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
        name: "password",
        required: true,
        autocomplete: "new-password",
        id: "new-password",
        onChange: value => setPassword(value),
        right: {
          icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password
      }), /*#__PURE__*/jsx(Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsx(FormFieldWithIconButton, {
        name: "confirm-password",
        required: true,
        autocomplete: "new-password",
        id: "confirm-password",
        onChange: value => setConfirmPassword(value),
        right: {
          icon: showPassword ? /*#__PURE__*/jsx(EyeClosedIcon, {}) : /*#__PURE__*/jsx(EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Confirm Password",
        type: showPassword ? "text" : "password",
        value: confirmPassword,
        error: passwordMismatch ? "Passwords don't match" : ""
      }), /*#__PURE__*/jsx(Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsx(Button, {
        variant: "inverted",
        type: "submit",
        style: {
          width: "100%"
        },
        children: "Create Wallet"
      })]
    }), /*#__PURE__*/jsx(Spacer, {
      y: "xxl"
    }), /*#__PURE__*/jsx(TextDivider, {
      children: /*#__PURE__*/jsx("span", {
        children: "OR"
      })
    }), /*#__PURE__*/jsx(Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsx(HelperLink, {
      as: "button",
      onClick: () => {
        setShowImportScreen(true);
      },
      style: {
        textAlign: "center",
        width: "100%"
      },
      children: "Import a JSON wallet"
    })]
  });
};
const TextDivider = styled.div`
  display: flex;
  align-items: center;
  color: ${p => p.theme.text.secondary};
  font-size: ${fontSize.sm};
  &::before,
  &::after {
    content: "";
    flex: 1;
    border-bottom: 1px solid ${p => p.theme.bg.highlighted};
  }

  span {
    margin: 0 1rem;
  }
`;
const InfoCircledIconSecondary = styled(InfoCircledIcon)`
  color: ${p => p.theme.text.secondary};
`;

const ConnectToDeviceWallet = props => {
  const {
    storageLoading,
    walletData,
    refreshSavedData
  } = useDeviceWalletInfo();
  if (storageLoading) {
    return /*#__PURE__*/jsx(LoadingSpinnerContainer, {
      children: /*#__PURE__*/jsx(Spinner, {
        size: "lg",
        color: "primary"
      })
    });
  }
  return /*#__PURE__*/jsx(Fragment, {
    children: !walletData ? /*#__PURE__*/jsx(CreateDeviceWallet, {
      onConnected: props.onConnected,
      onBack: props.onBack
    }) : /*#__PURE__*/jsx(ReconnectDeviceWallet, {
      onConnected: props.onConnected,
      onRemove: () => {
        refreshSavedData();
      },
      onBack: props.onBack
    })
  });
};
const LoadingSpinnerContainer = styled.div`
  height: 300px;
  display: flex;
  align-items: center;
  justify-content: center;
`;

const ConnectModal = () => {
  const modalTheme = useModalTheme();
  const isConnectingToSafe = useIsConnectingToSafe();
  const showScreen = useScreen();
  const setShowScreen = useSetScreen();
  const setIsConnectingToSafe = useSetIsConnectingToSafe();
  const isWalletModalOpen = useIsWalletModalOpen();
  const setIsWalletModalOpen = useSetIsWalletModalOpen();
  const connectionStatus = useConnectionStatus();
  const disconnect = useDisconnect();
  const connect = useConnect();
  const wallets = useWallets();
  const installedWallets = useInstalledWallets();

  // to hide the modal temporarily when showing the third party Modal to avoid z-index issues
  const [hideModal, setHideModal] = useState(false);
  const closeModalAndReset = useCallback(() => {
    setShowScreen("walletList");
    setIsConnectingToSafe(false);
    setIsWalletModalOpen(false);
  }, [setIsConnectingToSafe, setIsWalletModalOpen, setShowScreen]);
  const onConnect = useCallback(() => {
    if (isConnectingToSafe) {
      setShowScreen("safe/form");
    } else {
      closeModalAndReset();
    }
  }, [closeModalAndReset, isConnectingToSafe, setShowScreen]);
  const onConnectError = useCallback(() => {
    if (isConnectingToSafe) {
      setShowScreen("safe/select-wallet");
    } else {
      setShowScreen("walletList");
    }
  }, [isConnectingToSafe, setShowScreen]);
  const handleBack = useCallback(() => {
    if (isConnectingToSafe) {
      setShowScreen("safe/select-wallet");
    } else {
      setShowScreen("walletList");
    }
  }, [isConnectingToSafe, setShowScreen]);
  const walletsMeta = wallets.map(wallet => ({
    id: wallet.id,
    name: wallet.meta.name,
    iconURL: wallet.meta.iconURL,
    installed: wallet.id in installedWallets && installedWallets[wallet.id],
    onClick: async () => {
      // Metamask
      if (wallet.id === "metamask") {
        if (installedWallets.metamask) {
          try {
            await ifWaiting({
              for: connect(wallet, {}),
              moreThan: 100,
              do: () => {
                setShowScreen("metamask/connecting");
              }
            });
            onConnect();
          } catch (e) {
            onConnectError();
          }
        }

        // if metamask is not injected
        else {
          // on mobile, open metamask app link
          if (isMobile()) {
            window.open(`https://metamask.app.link/dapp/${window.location.toString()}`);
          } else {
            // on desktop, show the metamask scan qr code
            setShowScreen("metamask/scan");
          }
        }
      }

      // Coinbase Wallet
      else if (wallet.id === "coinbaseWallet") {
        if (installedWallets.coinbaseWallet) {
          try {
            await ifWaiting({
              for: connect(wallet, {}),
              moreThan: 100,
              do: () => {
                setShowScreen("coinbase/connecting");
              }
            });
            onConnect();
          } catch (e) {
            onConnectError();
          }
        } else {
          if (isMobile()) {
            // coinbase will redirect to download page for coinbase wallet apps
            connect(wallet, {});
          } else {
            setShowScreen("coinbase/scan");
          }
        }
      }

      // Safe
      else if (wallet.id === "Safe") {
        setIsConnectingToSafe(true);
        setShowScreen("safe/select-wallet");
      }

      // Device Wallet
      else if (wallet.id === "deviceWallet") {
        setShowScreen("deviceWallet/connect");
      }

      // others ( they handle their own connection flow)
      else {
        try {
          setHideModal(true);
          await connect(wallet, {});
          onConnect();
          setHideModal(false);
        } catch (e) {
          onConnectError();
          setHideModal(false);
          console.error(e);
        }
      }
    }
  }));
  return /*#__PURE__*/jsx(ThemeProvider, {
    theme: typeof modalTheme === "object" ? modalTheme : modalTheme === "light" ? lightTheme : darkTheme,
    children: /*#__PURE__*/jsxs(Modal, {
      style: {
        maxWidth: "480px"
      },
      open: hideModal ? false : isWalletModalOpen,
      setOpen: value => {
        setIsWalletModalOpen(value);
        if (!value) {
          closeModalAndReset();
          if (connectionStatus === "connecting") {
            disconnect();
          }
        }
      },
      children: [showScreen === "walletList" && /*#__PURE__*/jsx(WalletSelector, {
        walletsMeta: walletsMeta,
        onGetStarted: () => {
          setShowScreen("wallets/get-started");
        }
      }), showScreen === "metamask/get-started" && /*#__PURE__*/jsx(MetamaskGetStarted, {
        onBack: () => {
          setShowScreen("metamask/scan");
        }
      }), showScreen === "coinbase/get-started" && /*#__PURE__*/jsx(CoinbaseGetStarted, {
        onBack: () => {
          setShowScreen("coinbase/scan");
        }
      }), showScreen === "metamask/connecting" && /*#__PURE__*/jsx(MetamaskConnecting, {
        onBack: handleBack
      }), showScreen === "metamask/scan" && /*#__PURE__*/jsx(ScanMetamask, {
        onBack: handleBack,
        onConnected: onConnect,
        onGetStarted: () => {
          setShowScreen("metamask/get-started");
        }
      }), showScreen === "coinbase/scan" && /*#__PURE__*/jsx(ScanCoinbase, {
        onBack: handleBack,
        onConnected: onConnect,
        onGetStarted: () => {
          setShowScreen("coinbase/get-started");
        }
      }), showScreen === "coinbase/connecting" && /*#__PURE__*/jsx(CoinbaseWalletSetup, {
        onBack: handleBack
      }), showScreen === "safe/select-wallet" && /*#__PURE__*/jsx(SelectpersonalWallet, {
        onBack: () => {
          setIsConnectingToSafe(false);
          setShowScreen("walletList");
        },
        walletsMeta: walletsMeta
      }), showScreen === "safe/form" && /*#__PURE__*/jsx(SafeForm, {
        onBack: handleBack,
        onConnect: () => {
          closeModalAndReset();
        }
      }), showScreen === "wallets/get-started" && /*#__PURE__*/jsx(GetStartedWithWallets, {
        onBack: handleBack
      }), showScreen === "deviceWallet/connect" && /*#__PURE__*/jsx(ConnectToDeviceWallet, {
        onBack: handleBack,
        onConnected: onConnect
      })]
    })
  });
};

/**
 *
 * The `<ThirdwebProvider />` component lets you control what networks you want users to connect to,
 * what types of wallets can connect to your app, and the settings for the [Thirdweb SDK](https://docs.thirdweb.com/typescript).
 *
 * @example
 * You can wrap your application with the provider as follows:
 *
 * ```jsx title="App.jsx"
 * import { ThirdwebProvider } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *   return (
 *     <ThirdwebProvider>
 *       <YourApp />
 *     </ThirdwebProvider>
 *   );
 * };
 * ```
 *
 */
const ThirdwebProvider = _ref => {
  let {
    thirdwebApiKey = DEFAULT_API_KEY,
    supportedWallets,
    theme,
    children,
    ...restProps
  } = _ref;
  return /*#__PURE__*/jsx(WalletUIStatesProvider, {
    theme: theme,
    children: /*#__PURE__*/jsx(ThemeProvider, {
      theme: theme === "dark" ? darkTheme : lightTheme,
      children: /*#__PURE__*/jsxs(ThirdwebProviderCore, {
        theme: theme,
        thirdwebApiKey: thirdwebApiKey,
        supportedWallets: supportedWallets || [metamaskWallet(), coinbaseWallet(), walletConnectV1()],
        ...restProps,
        children: [children, /*#__PURE__*/jsx(ConnectModal, {})]
      })
    })
  });
};

function useMetamask() {
  const connect = useConnect();
  return useCallback(async connectOptions => {
    const {
      metamaskWallet
    } = await Promise.resolve().then(function () { return metamaskWallet$1; });
    connect(metamaskWallet(), connectOptions);
  }, [connect]);
}

function useCoinbaseWallet() {
  const connect = useConnect();
  return useCallback(async connectOptions => {
    const {
      coinbaseWallet
    } = await Promise.resolve().then(function () { return coinbaseWallet$1; });
    connect(coinbaseWallet(), connectOptions);
  }, [connect]);
}

function usePaperWallet() {
  const connect = useConnect();
  return useCallback(async options => {
    const {
      paperWallet
    } = await import('./paperWallet-b91cd78d.esm.js');
    connect(paperWallet({
      clientId: options.clientId
    }), options);
  }, [connect]);
}
function usePaperWalletUserEmail() {
  const wallet = useWallet();
  const queryClient = useQueryClient();
  const emailQuery = useQuery([wallet?.walletId, "paper-email"], () => {
    if (!wallet || wallet.walletId !== "PaperWallet") {
      throw "Not connected to Paper Wallet";
    }
    return wallet.getEmail();
  }, {
    retry: false
  });

  // Invalidate the query when the wallet changes
  useEffect(() => {
    queryClient.invalidateQueries([wallet?.walletId, "paper-email"]);
  }, [wallet, queryClient]);
  return emailQuery;
}

function useWalletConnectV1() {
  const connect = useConnect();
  return useCallback(async options => {
    const {
      walletConnectV1
    } = await Promise.resolve().then(function () { return walletConnectV1$1; });
    connect(walletConnectV1(), options);
  }, [connect]);
}
function useWalletConnect() {
  const connect = useConnect();
  return useCallback(async options => {
    const {
      walletConnect
    } = await import('./walletConnect-f2a94c36.esm.js');
    connect(walletConnect(), options || {});
  }, [connect]);
}

export { ConnectWallet as C, MediaRenderer as M, NetworkSelector as N, ThirdwebProvider as T, Web3Button as W, useMetamask as a, useCoinbaseWallet as b, coinbaseWallet as c, usePaperWalletUserEmail as d, usePaperWallet as e, useWalletConnect as f, useWalletConnectV1 as g, useResolvedMediaType as h, ThirdwebNftMedia as i, metamaskWallet as m, useInstalledWallets as u, walletConnectV1 as w };
